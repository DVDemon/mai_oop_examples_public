# Пример: Корутины (C++20) - Простой генератор

## Описание

Данный пример демонстрирует использование **корутин (coroutines)** в C++20 для создания **генератора последовательности** - функции, которая может приостанавливать выполнение и возвращать значения по требованию.

## Суть примера

### Что такое корутины?

**Корутины** - это функции, которые могут:
- **Приостанавливать** выполнение (`co_yield`, `co_await`)
- **Возобновлять** выполнение позже
- **Сохранять состояние** между вызовами
- **Возвращать значения** постепенно

### Генератор последовательности

```cpp
Generator sequence(int start, int end) {
    for (int i = start; i <= end; ++i) {
        co_yield i;  // Приостанавливает выполнение и возвращает значение
    }
}
```

**Использование:**
```cpp
auto gen = sequence(1, 50);
while (gen.move_next()) {
    std::cout << gen.current_value() << std::endl;
}
```

## Архитектура корутины

### Класс Generator

```cpp
struct Generator {
    struct promise_type {
        std::optional<int> current_value;
        // Методы управления корутиной
    };
    std::coroutine_handle<promise_type> coro;
};
```

**Компоненты:**
- **`promise_type`** - определяет поведение корутины
- **`coroutine_handle`** - управляет жизнью корутины
- **`current_value`** - хранит текущее значение

### Методы promise_type

#### get_return_object()

```cpp
Generator get_return_object() {
    return Generator{std::coroutine_handle<promise_type>::from_promise(*this)};
}
```

**Назначение:** Создает объект, возвращаемый из корутины.

#### initial_suspend() и final_suspend()

```cpp
std::suspend_always initial_suspend() { return {}; }
std::suspend_always final_suspend() noexcept { return {}; }
```

**Назначение:**
- **`initial_suspend()`** - приостанавливает корутину сразу после создания
- **`final_suspend()`** - приостанавливает корутину перед завершением

**Типы:**
- **`suspend_always`** - всегда приостанавливает
- **`suspend_never`** - никогда не приостанавливает

#### yield_value()

```cpp
std::suspend_always yield_value(int value) {
    current_value = value;
    return {};
}
```

**Назначение:** Обрабатывает `co_yield` - сохраняет значение и приостанавливает корутину.

#### unhandled_exception()

```cpp
void unhandled_exception() {
    std::terminate();
}
```

**Назначение:** Обрабатывает необработанные исключения в корутине.

## Принцип работы

### Жизненный цикл корутины

```
Создание корутины:
    sequence(1, 50) → promise_type создан
    ↓
    initial_suspend() → корутина приостановлена
    ↓
    get_return_object() → Generator создан
    ↓
    [корутина готова, но не выполняется]

Использование:
    gen.move_next() → coro.resume()
    ↓
    [корутина возобновлена]
    ↓
    for (int i = start; i <= end; ++i)
    ↓
    co_yield i → yield_value(i)
    ↓
    [значение сохранено, корутина приостановлена]
    ↓
    gen.current_value() → возвращает значение
    ↓
    [повторяется до завершения цикла]

Завершение:
    [цикл завершен]
    ↓
    final_suspend() → корутина приостановлена
    ↓
    coro.done() == true
    ↓
    [корутина завершена]
```

### Управление корутиной

```cpp
bool move_next() {
    coro.resume();           // Возобновляет выполнение
    return !coro.done();     // Проверяет завершение
}

int current_value() {
    return *coro.promise().current_value;  // Получает значение
}
```

## Преимущества корутин

### Эффективность памяти

- **Ленивое вычисление** - значения генерируются по требованию
- **Не хранит всю последовательность** - только текущее значение
- **Экономия памяти** - для больших последовательностей

### Читаемость кода

- **Последовательный код** - выглядит как обычная функция
- **Нет callback'ов** - не нужны сложные цепочки
- **Простота** - легко понять логику

### Гибкость

- **Приостановка и возобновление** - полный контроль над выполнением
- **Состояние сохраняется** - между вызовами
- **Асинхронность** - можно использовать для асинхронных операций

## Сравнение с другими подходами

### Традиционный подход (вектор)

```cpp
std::vector<int> sequence(int start, int end) {
    std::vector<int> result;
    for (int i = start; i <= end; ++i)
        result.push_back(i);
    return result;  // Возвращает весь вектор
}
```

**Проблемы:**
- Хранит все значения в памяти
- Неэффективно для больших последовательностей
- Нужно ждать генерации всех значений

### Корутины (24_CoSimple)

```cpp
Generator sequence(int start, int end) {
    for (int i = start; i <= end; ++i)
        co_yield i;  // Генерирует по требованию
}
```

**Преимущества:**
- Генерирует значения по требованию
- Эффективно по памяти
- Можно обрабатывать бесконечные последовательности

## Типичные применения

### Генераторы последовательностей

- Числовые последовательности
- Фильтрация данных
- Трансформация данных

### Асинхронные операции

- Асинхронный I/O
- Сетевые запросы
- Параллельная обработка

### State machines

- Парсинг
- Игровые логики
- UI состояния

## Важные моменты

### Управление памятью

```cpp
~Generator() {
    if (coro) coro.destroy();  // Освобождает ресурсы корутины
}
```

**Важно:** Нужно явно уничтожать корутину, иначе утечка памяти.

### Перемещение и копирование

```cpp
Generator(Generator&& other) noexcept : coro(other.coro) {
    other.coro = nullptr;  // Перемещение
}

Generator(const Generator&) = delete;  // Запрет копирования
```

**Почему:**
- Корутины нельзя копировать (уникальный ресурс)
- Можно только перемещать
- После перемещения исходный объект невалиден

### Проверка завершения

```cpp
while (gen.move_next()) {  // Проверяет !coro.done()
    // обработка
}
```

**Важно:** Всегда проверять `done()` перед использованием значения.

## Связь с предыдущими примерами

- `05_LambdaGen` - генераторы через лямбды (функциональный подход)
- `20_Future` - асинхронность через `std::async`
- `23_CustomAsync` - асинхронная обработка событий
- `24_CoSimple` - корутины для генераторов (современный C++20 подход)

Это демонстрирует эволюцию подходов к генерации последовательностей и асинхронности: от функциональных генераторов через лямбды к современным корутинам C++20, которые предоставляют более элегантный и эффективный способ создания генераторов и асинхронных операций.

