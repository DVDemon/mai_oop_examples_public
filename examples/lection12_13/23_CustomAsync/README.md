# Пример: Собственный Event Loop (Асинхронная обработка событий)

## Описание

Данный пример демонстрирует реализацию **собственного event loop (цикла событий)** для асинхронной обработки событий в многопоточной среде - паттерн Producer-Consumer, где один поток производит события, а другой их обрабатывает.

## Суть примера

### Архитектура Event Loop

```cpp
class EventLoop {
    std::queue<Event> m_event_queue;      // Очередь событий
    std::vector<Handler*> m_handlers;     // Обработчики событий
    bool m_quit = false;                   // Флаг завершения
};
```

**Компоненты:**
- **Очередь событий** - хранит события для обработки
- **Обработчики** - список обработчиков для событий
- **Флаг завершения** - управляет жизнью цикла

### Цикл обработки событий

```cpp
int exec() {
    while (!m_quit) {
        if (!m_event_queue.empty()) {
            auto ev = m_event_queue.front();
            m_event_queue.pop();
            // Обработка события
        } else {
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
    }
}
```

**Принцип работы:**
1. Проверяет очередь событий
2. Если есть события - обрабатывает их
3. Если очередь пуста - ждет (sleep)
4. Продолжает до флага `m_quit`

### Отправка событий

```cpp
void send(const Event& event) {
    m_event_queue.push(event);
}
```

События добавляются в очередь из любого потока.

## Принцип работы

### Producer-Consumer паттерн

```
Поток Producer (userThread):    Поток Consumer (eventLoop.exec()):
    ↓                                ↓
[создан]                        [запущен]
    ↓                                ↓
send(Event::new_doc)            [проверяет очередь]
    ↓                                ↓
[событие в очереди]             [обрабатывает событие]
    ↓                                ↓
[sleep 1 сек]                  [вызывает handler]
    ↓                                ↓
[send еще событие]              [продолжает цикл]
    ↓                                ↓
[...]                           [...]
    ↓                                ↓
send(Event::quit)               [обрабатывает quit]
    ↓                                ↓
[завершается]                   [m_quit = true]
    ↓                                ↓
                                [завершается]
```

### Обработка событий

```cpp
switch (ev.code) {
    case EventCode::quit:
        m_quit = true;  // Завершение цикла
        break;
    default:
        for (auto handler : m_handlers) {
            if (handler->event(ev))
                break;  // Обработчик принял событие
        }
}
```

**Логика обработки:**
- Специальные события (quit) обрабатываются напрямую
- Обычные события передаются обработчикам
- Первый принявший обработчик останавливает цепочку

## Архитектура обработчиков

### Интерфейс Handler

```cpp
struct Handler {
    virtual bool event(const Event&) = 0;
};
```

**Метод `event()`:**
- Возвращает `true` если событие обработано
- Возвращает `false` если событие не обработано
- Позволяет цепочку обработчиков

### Реализация PrintHandler

```cpp
struct PrintHandler : Handler {
    bool event(const Event& event) override {
        std::cout << "code = " << static_cast<int>(event.code)
                  << "\ndata = " << event.data << std::endl;
        return true;  // Событие обработано
    }
};
```

## Преимущества Event Loop

### Асинхронность

- **Неблокирующая обработка** - события обрабатываются асинхронно
- **Разделение ответственности** - producer и consumer разделены
- **Масштабируемость** - можно добавить больше потоков-producer

### Гибкость

- **Множественные обработчики** - цепочка обработчиков
- **Типы событий** - разные события, разные обработчики
- **Расширяемость** - легко добавить новые обработчики

### Простота

- **Единая точка входа** - все события через `send()`
- **Централизованная обработка** - один цикл обработки
- **Управление жизнью** - простое завершение через `quit`

## Проблемы текущей реализации

### Отсутствие синхронизации

```cpp
void send(const Event& event) {
    m_event_queue.push(event);  // НЕ защищено мьютексом!
}
```

**Проблема:**
- `std::queue` не потокобезопасна
- Одновременный доступ из разных потоков = **race condition**
- Нужен мьютекс для защиты очереди

### Busy waiting

```cpp
if (!m_event_queue.empty()) {
    // обработка
} else {
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
}
```

**Проблема:**
- Поток постоянно проверяет очередь (даже с sleep)
- Неэффективное использование CPU
- Лучше использовать `condition_variable` (как в `22_Conditional`)

## Улучшенная версия (концептуально)

### С синхронизацией

```cpp
class EventLoop {
    std::mutex m_mtx;
    std::condition_variable m_cv;
    std::queue<Event> m_event_queue;
    
    void send(const Event& event) {
        std::lock_guard<std::mutex> lck(m_mtx);
        m_event_queue.push(event);
        m_cv.notify_one();  // Пробуждает exec()
    }
    
    int exec() {
        std::unique_lock<std::mutex> lck(m_mtx);
        while (!m_quit) {
            while (m_event_queue.empty() && !m_quit)
                m_cv.wait(lck);  // Ждет событий
            // обработка...
        }
    }
};
```

## Типичные применения

### GUI приложения

- События от пользователя (клики, нажатия)
- Обработка в главном потоке
- Неблокирующий UI

### Серверные приложения

- События от клиентов
- Асинхронная обработка запросов
- Масштабируемость

### Игровые движки

- События игры (коллизии, действия)
- Централизованная обработка
- Предсказуемый порядок

## Связь с предыдущими примерами

- `20_Future` - высокоуровневая асинхронность через `std::async`
- `21_Promise` - явная передача данных между потоками
- `22_Conditional` - условная синхронизация (решение для event loop)
- `23_CustomAsync` - реализация собственного event loop

Это демонстрирует практическое применение многопоточности для создания асинхронных систем обработки событий, показывая как объединить различные механизмы синхронизации в единую архитектуру.

