# Пример: Корутины - Практическое применение (Игровая симуляция)

## Описание

Данный пример демонстрирует **практическое применение корутин** для создания игровой симуляции - система управления множественными "рейнджерами", которые перемещаются по карте и взаимодействуют друг с другом. Показывает, как корутины упрощают управление состоянием множественных сущностей.

## Суть примера

### Игровая симуляция

```cpp
Ranger ranger_action(size_t id, int min_x, int min_y, int max_x, int max_y) {
    Stats stats {x, y, id, strength, true};
    
    while(stats.alive) {
        // Движение рейнджера
        // ...
        co_yield stats;  // Возвращает состояние после движения
    }
}
```

**Особенности:**
- **Множественные корутины** - каждый рейнджер = отдельная корутина
- **Составное состояние** - возвращает структуру `Stats`
- **Управление жизнью** - корутина работает пока `alive == true`
- **Пошаговая симуляция** - состояние обновляется по шагам

### Структура состояния

```cpp
struct Stats {
    int x, y;           // Координаты
    size_t id;          // Идентификатор
    int strength;       // Сила
    bool alive;         // Жив ли рейнджер
};
```

**Компоненты состояния:**
- **Позиция** - координаты на карте
- **Идентификатор** - уникальный ID рейнджера
- **Характеристики** - сила для боя
- **Статус** - жив или мертв

## Принцип работы

### Цикл симуляции

```
Инициализация:
    Создание 10 рейнджеров (корутин)
    ↓
    [каждый рейнджер приостановлен]

Фаза движения:
    for (каждый рейнджер):
        ranger.move_next()  → возобновление корутины
        ↓
        [рейнджер перемещается]
        ↓
        co_yield stats  → возврат состояния
        ↓
        [сохранение состояния]

Фаза боя:
    Проверка расстояния между рейнджерами
    ↓
    Если близко и сила меньше → alive = false
    ↓
    [обновление состояний]

Повтор:
    [нажатие Enter]
    ↓
    [новая фаза движения]
```

### Движение рейнджера

```cpp
int distance = std::rand() % 20;
switch(std::rand() % 4) {
    case 0: // left
        while ((stats.x > min_x) && (distance > 0)) {
            --stats.x;
            --distance;
            std::this_thread::sleep_for(100ms);  // Визуализация
        }
        break;
    // ... другие направления
}
co_yield stats;  // Возврат состояния после движения
```

**Особенности:**
- **Случайное направление** - выбор из 4 направлений
- **Случайная дистанция** - до 20 шагов
- **Визуализация** - задержка для отображения движения
- **Границы карты** - проверка границ перед движением

## Архитектура

### Корутина Ranger

```cpp
struct Ranger {
    struct promise_type {
        std::optional<Stats> current_stats;  // Текущее состояние
        
        std::suspend_always yield_value(Stats stats) {
            current_stats = stats;
            return {};
        }
    };
    
    Stats& get_stats() {
        return *(coro.promise().current_stats);
    }
};
```

**Компоненты:**
- **Promise type** - хранит состояние рейнджера
- **Yield value** - принимает структуру `Stats`
- **Get stats** - возвращает ссылку на состояние

### Управление множественными корутинами

```cpp
std::list<Ranger> rangers;
for(size_t i = 0; i < 10; ++i)
    rangers.push_back(ranger_action(i, min_x, min_y, max_x, max_y));

std::map<int, Stats> stats;
for(auto &r : rangers) {
    r.move_next();              // Возобновление корутины
    stats[index] = r.get_stats();  // Сохранение состояния
}
```

**Особенности:**
- **Контейнер корутин** - список рейнджеров
- **Централизованное управление** - все корутины в одном месте
- **Синхронизация** - все рейнджеры двигаются одновременно

## Преимущества корутин для симуляций

### Управление состоянием

**Без корутин (традиционный подход):**
```cpp
class Ranger {
    Stats stats;
    void update() {
        // Обновление состояния
        // Нужно хранить состояние в классе
    }
};

std::vector<Ranger> rangers;
for(auto& r : rangers) {
    r.update();  // Явное управление
}
```

**Проблемы:**
- Нужно хранить состояние в классе
- Явное управление обновлением
- Сложнее управлять множественными сущностями

**С корутинами:**
```cpp
Ranger ranger_action(...) {
    Stats stats;
    while(stats.alive) {
        // Обновление состояния
        co_yield stats;  // Автоматическое сохранение
    }
}
```

**Преимущества:**
- Состояние хранится в корутине
- Автоматическое управление
- Проще управлять множественными сущностями

### Пошаговая симуляция

```cpp
// Фаза движения
for(auto &r : rangers) {
    r.move_next();  // Каждый рейнджер делает шаг
}

// Фаза боя
// Обработка взаимодействий

// Ожидание следующего шага
std::cin.get();
```

**Преимущества:**
- **Контроль темпа** - можно контролировать скорость симуляции
- **Отладка** - легко остановить и проверить состояние
- **Визуализация** - можно отображать каждый шаг

### Независимость сущностей

```cpp
for(size_t i = 0; i < 10; ++i)
    rangers.push_back(ranger_action(i, ...));
```

**Каждый рейнджер:**
- Имеет свое независимое состояние
- Выполняется независимо
- Может завершиться в любой момент (alive = false)

## Механика игры

### Движение

- **Случайное направление** - влево, вправо, вверх, вниз
- **Случайная дистанция** - до 20 шагов
- **Границы карты** - не может выйти за границы
- **Визуализация** - отображение движения пошагово

### Бой

```cpp
if (std::pow(left.x-right.x,2) + std::pow(left.y-right.y,2) < 400) {
    if (left.strength < right.strength) {
        left.alive = false;  // Слабый рейнджер умирает
    }
}
```

**Условия боя:**
- **Расстояние** - рейнджеры должны быть близко (< 20 единиц)
- **Сравнение силы** - слабый рейнджер умирает
- **Проверка жизни** - только живые рейнджеры сражаются

## Типичные применения

### Игровые симуляции

- Пошаговые стратегии
- Симуляции жизни
- Эволюционные алгоритмы
- Моделирование поведения

### Системы с множественными агентами

- Робототехника
- Транспортные системы
- Социальные симуляции
- Экономические модели

### Управление ресурсами

- Планировщики задач
- Системы очередей
- Управление процессами
- Event-driven системы

## Важные моменты

### Управление жизнью корутин

```cpp
if (stats.find(index) != std::end(stats)) 
    alive = stats[index].alive;

if(alive) {
    r.move_next();  // Только живые рейнджеры двигаются
    stats[index] = r.get_stats();
}
```

**Важно:** Проверять состояние перед возобновлением корутины.

### Сохранение состояния

```cpp
stats[index] = std::move(r.get_stats());  // Move semantics
```

**Оптимизация:** Использование move semantics для эффективного копирования.

### Синхронизация

```cpp
std::cin.get();  // Ожидание перед следующим шагом
```

**Контроль:** Можно контролировать темп симуляции через пользовательский ввод.

## Связь с предыдущими примерами

- `24_CoSimple` - базовые корутины с одним значением
- `25_CoFibonacci` - бесконечные последовательности
- `26_Multivalue` - возврат составных типов (pair)
- `27_Ranger` - практическое применение: игровая симуляция с множественными корутинами

Это демонстрирует переход от простых примеров к реальным применениям корутин, показывая как они упрощают управление состоянием множественных сущностей в симуляциях и играх.

