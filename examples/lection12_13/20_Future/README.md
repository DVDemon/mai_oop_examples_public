# Пример: std::future и std::async (Асинхронное выполнение)

## Описание

Данный пример демонстрирует использование **`std::future`** и **`std::async`** для асинхронного выполнения задач и получения результатов - высокоуровневый подход к многопоточности в C++.

## Суть примера

### std::async - асинхронный запуск

```cpp
std::future<bool> fut = std::async(is_prime, 444444443);
```

`std::async` запускает функцию **асинхронно**:
- Возвращает `std::future` для получения результата
- Функция может выполняться в отдельном потоке
- Основной поток продолжает работу

### std::future - получение результата

```cpp
while (fut.wait_for(span) == std::future_status::timeout)
    std::cout << '.' << std::flush;

bool x = fut.get();  // Получение результата
```

`std::future` предоставляет:
- **`wait_for()`** - проверка статуса с таймаутом
- **`get()`** - получение результата (блокирует до завершения)
- **Статусы** - `ready`, `timeout`, `deferred`

## Принцип работы

### Асинхронное выполнение

```
Основной поток:          Асинхронный поток:
    ↓                         ↓
async() → [запуск]      → is_prime() выполняется
    ↓                         ↓
[работает]              → [вычисляет]
    ↓                         ↓
wait_for() → проверка   → [продолжает]
    ↓                         ↓
get() → [ждет]          → [завершает]
    ↓                         ↓
[получает результат]    → [возвращает]
```

### Использование лямбд

```cpp
std::async([](unsigned long long x) {
    for (unsigned long long i=2; i<x; ++i) 
        if (x%i==0) return false;
    return true;
}, 444444443).get()
```

Лямбды можно использовать напрямую с `std::async`.

## Преимущества std::async/future

### Простота использования

- **Высокоуровневый API** - не нужно управлять потоками вручную
- **Автоматическое управление** - `std::async` управляет жизнью потока
- **Получение результата** - удобный способ получить возвращаемое значение

### Безопасность

- **Нет проблем с передачей данных** - результат передается безопасно
- **Нет утечек** - данные не "утекают" наружу (в отличие от `19_PassOut`)
- **Исключения** - автоматически передаются через `future`

### Гибкость

- **Проверка статуса** - можно проверять готовность результата
- **Таймауты** - `wait_for()` позволяет не блокироваться навсегда
- **Отложенное выполнение** - можно отложить запуск

## Сравнение с std::thread

### std::thread (08_Thread)

```cpp
std::thread t(is_prime, 444444443);
// Нужно join()
// Нет способа получить результат напрямую
```

**Проблемы:**
- Нужно управлять потоком вручную
- Нет прямого способа получить результат
- Нужно использовать shared variables или другие механизмы

### std::async + std::future (20_Future)

```cpp
auto fut = std::async(is_prime, 444444443);
bool result = fut.get();  // Просто получить результат
```

**Преимущества:**
- Автоматическое управление
- Прямое получение результата
- Безопасная передача данных

## Статусы future

- **`std::future_status::ready`** - результат готов
- **`std::future_status::timeout`** - еще не готов (таймаут)
- **`std::future_status::deferred`** - выполнение отложено

## Когда использовать

**Используйте `std::async`/`std::future` когда:**
- Нужно получить **результат** из асинхронной операции
- Важна **простота** использования
- Нужна **безопасная передача** данных

**Используйте `std::thread` когда:**
- Нужен **полный контроль** над потоком
- Не нужен результат (fire-and-forget)
- Требуется **специфическая логика** управления потоками

## Связь с предыдущими примерами

- `08_Thread` - низкоуровневое создание потоков
- `19_PassOut` - проблема утечки данных при передаче
- `20_Future` - высокоуровневый безопасный способ получения результатов
- `21_Promise` - более детальный контроль над future (следующий пример)

Это демонстрирует эволюцию от низкоуровневых потоков к высокоуровневым абстракциям для асинхронного программирования.

