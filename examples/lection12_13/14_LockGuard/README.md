# Пример: Автоматическое управление мьютексами (lock_guard)

## Описание

Данный пример демонстрирует использование **`std::lock_guard`** для автоматического управления мьютексами по принципу **RAII** - гарантированное освобождение мьютекса даже при исключениях.

## Суть примера

### Проблема с ручным управлением

В примере `12_Mutex` использовалось ручное управление:
```cpp
lock->lock();
// ... критическая секция ...
lock->unlock();  // Что если здесь исключение?
```

**Проблема:** Если в критической секции произойдет исключение, `unlock()` может не быть вызван.

### Решение: std::lock_guard

```cpp
void threadFunction(std::mutex *lock) {
    try {
        std::lock_guard<std::mutex> guard(*lock);  // Автоматический lock
        std::cout << "entered thread " << std::this_thread::get_id() << std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(rand() % 5));
        
        throw 0;  // Исключение!
        // unlock() вызывается автоматически в деструкторе guard
    }
    catch (...) {
        // Мьютекс уже разблокирован!
    }
}
```

## Принцип работы

### RAII (Resource Acquisition Is Initialization)

`std::lock_guard` - это обертка, которая:
- **В конструкторе** вызывает `lock()` на мьютексе
- **В деструкторе** автоматически вызывает `unlock()`
- Гарантирует освобождение мьютекса при выходе из области видимости

### Жизненный цикл

```cpp
{
    std::lock_guard<std::mutex> guard(*lock);
    // ↑ Конструктор: lock->lock()
    
    // Критическая секция
    // Даже если здесь throw - деструктор вызовется!
    
}  // ← Деструктор: lock->unlock() (автоматически)
```

## Преимущества lock_guard

### Безопасность при исключениях

```cpp
std::lock_guard<std::mutex> guard(*lock);
throw 0;  // Исключение!
// Мьютекс автоматически разблокируется в деструкторе
```

**Гарантия:** Мьютекс будет разблокирован даже при исключении.

### Простота использования

- **Не нужно помнить** о `unlock()`
- **Автоматическое управление** - работает по принципу RAII
- **Идиоматичный код** - стандартный подход в C++

### Защита от ошибок

- **Невозможно забыть** вызвать `unlock()`
- **Невозможно** вызвать `unlock()` дважды
- **Невозможно** забыть разблокировать при исключении

## Сравнение подходов

### Ручное управление (12_Mutex)

```cpp
lock->lock();
try {
    // критическая секция
    throw 0;
} catch (...) {
    // Нужно не забыть unlock()!
}
lock->unlock();  // Может не выполниться при исключении
```

**Проблемы:**
- Нужно помнить о `unlock()`
- При исключении может остаться заблокированным
- Сложнее поддерживать

### Автоматическое управление (14_LockGuard)

```cpp
{
    std::lock_guard<std::mutex> guard(*lock);
    // критическая секция
    throw 0;  // Безопасно!
}  // Автоматический unlock()
```

**Преимущества:**
- Автоматическое освобождение
- Безопасно при исключениях
- Проще и безопаснее

## Ограничения lock_guard

- **Нет ручного управления** - нельзя вызвать `unlock()` раньше времени
- **Одна область видимости** - блокировка на время жизни объекта
- **Нет try_lock** - всегда блокирует до получения мьютекса

Для более гибкого управления используйте `std::unique_lock` (позволяет отложенную блокировку и ранний unlock).

## Когда использовать

**Используйте `lock_guard` когда:**
- Нужна блокировка на время области видимости
- Важна безопасность при исключениях
- Нужна простота и надежность

**Используйте ручное управление когда:**
- Нужна более сложная логика блокировки
- Требуется `try_lock()` (неблокирующая попытка)
- Нужен ранний `unlock()` до конца области видимости

## Связь с предыдущими примерами

- `12_Mutex` - ручное управление мьютексами (проблема с исключениями)
- `13_MutexRecursive` - рекурсивные мьютексы
- `14_LockGuard` - автоматическое управление через RAII

Это демонстрирует эволюцию от ручного управления к автоматическому и безопасному.

