# Пример: Race Condition (Состояние гонки)

## Описание

Данный пример демонстрирует проблему **race condition (состояние гонки)** - когда несколько потоков одновременно обращаются к одной и той же переменной без синхронизации, что приводит к непредсказуемым результатам.

## Суть примера

### Два потока изменяют одну переменную

```cpp
long number = 0;

Scoped_Thread th1(std::thread(add_function, &number));   // Увеличивает
Scoped_Thread th2(std::thread(subst_function, &number)); // Уменьшает

// Ожидаемый результат: 0
// Реальный результат: непредсказуем!
```

### Функции потоков

```cpp
void add_function(long *number) {
    for(long i = 0; i < 1000000000L; i++) 
        (*number)++;  // Неатомарная операция!
}

void subst_function(long *number) {
    for(long i = 0; i < 1000000000L; i++) 
        (*number)--;  // Неатомарная операция!
}
```

## Проблема: неатомарные операции

Операция `(*number)++` на самом деле состоит из **трех шагов**:
1. **Чтение** значения из памяти: `temp = *number`
2. **Увеличение** значения: `temp = temp + 1`
3. **Запись** значения в память: `*number = temp`

### Что происходит при race condition

```
Поток 1: читает number = 0
Поток 2: читает number = 0  ← оба прочитали одно и то же!
Поток 1: увеличивает до 1
Поток 2: уменьшает до -1
Поток 1: записывает 1
Поток 2: записывает -1  ← результат потока 1 потерян!
```

## Почему результат непредсказуем

- **Порядок выполнения** операций непредсказуем
- **Переключение потоков** может произойти в любой момент
- **Кэш процессора** может содержать устаревшие значения
- **Результат зависит** от тайминга выполнения потоков

## Ожидаемый vs реальный результат

- **Ожидаемый**: `number = 0` (1 миллиард увеличений - 1 миллиард уменьшений)
- **Реальный**: может быть любое значение, часто далеко от 0
- **При каждом запуске**: результат может быть разным

## Почему это опасно

- **Потеря данных** - изменения одного потока могут быть потеряны
- **Некорректные результаты** - программа выдает неправильные данные
- **Сложность отладки** - проблема может проявляться непостоянно
- **Критические ошибки** - в реальных системах может привести к серьезным проблемам

## Решение проблемы

Для решения race condition нужна **синхронизация**:
- **Мьютексы** (`std::mutex`) - блокировка доступа к данным
- **Атомарные операции** (`std::atomic`) - атомарные операции без блокировок
- **Семафоры** - контроль доступа к ресурсам

Это будет показано в следующих примерах (`12_Mutex`, и т.д.).

## Визуализация проблемы

```
Время →
Поток 1: [чтение] [увеличение] [запись]
Поток 2:        [чтение] [уменьшение] [запись]
                ↑
         Race condition здесь!
         Оба потока читают одно значение
```

## Связь с предыдущими примерами

- `08_Thread` - базовое создание потоков
- `09_ThreadParameter` - передача параметров
- `10_ScopedThread` - безопасное управление потоками
- `11_RaceCondition` - демонстрация проблемы race condition
- `12_Mutex` - решение через мьютексы (следующий пример)

Это демонстрирует важность синхронизации в многопоточных программах.

