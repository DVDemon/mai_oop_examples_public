# Пример: Решение Race Condition через мьютексы

## Описание

Данный пример демонстрирует **решение проблемы race condition** с помощью **мьютексов (mutex)** - механизма синхронизации, который обеспечивает взаимное исключение доступа к общим данным.

## Суть примера

### Решение race condition

В отличие от примера `11_RaceCondition`, где операции выполнялись без синхронизации, здесь используется мьютекс:

```cpp
void add_function(long *number, std::mutex *lock) {
    for (long i = 0; i < 1000000L; i++) {
        lock->lock();      // Блокировка доступа
        (*number)++;
        lock->unlock();    // Разблокировка
    }
}
```

### Принцип работы мьютекса

**Мьютекс (mutual exclusion)** - объект синхронизации:
- **`lock()`** - блокирует доступ, если мьютекс свободен, или ждет, если занят
- **`unlock()`** - освобождает мьютекс, позволяя другому потоку получить доступ
- **Взаимное исключение** - только один поток может владеть мьютексом одновременно

## Как мьютекс решает проблему

### Без мьютекса (11_RaceCondition)

```
Поток 1: читает number = 0
Поток 2: читает number = 0  ← Race condition!
Поток 1: увеличивает до 1
Поток 2: уменьшает до -1
```

### С мьютексом (12_Mutex)

```
Поток 1: lock() → читает number = 0 → увеличивает → записывает 1 → unlock()
Поток 2: lock() → ждет... → читает number = 1 → уменьшает → записывает 0 → unlock()
```

**Результат:** Корректный! `number = 0` (как и ожидалось)

## Демонстрация блокировки

```cpp
void threadFunction(std::mutex *lock) {
    std::cout << "waiting thread " << std::this_thread::get_id() << std::endl;
    lock->lock();  // Поток ждет, если мьютекс занят
    std::cout << "entered thread " << std::this_thread::get_id() << std::endl;
    // Критическая секция - только один поток здесь
    std::this_thread::sleep_for(std::chrono::seconds(rand() % 3));
    std::cout << "leaving thread " << std::this_thread::get_id() << std::endl;
    lock->unlock();
}
```

Это демонстрирует:
- Потоки **ожидают** друг друга
- Только **один поток** выполняет критическую секцию
- Порядок вывода показывает последовательный доступ

## Критическая секция

**Критическая секция** - часть кода между `lock()` и `unlock()`:
- Только один поток может выполнять эту секцию одновременно
- Обеспечивает безопасный доступ к общим данным
- Должна быть **минимальной** для производительности

## Важные моменты

### Обязательность unlock()

- **Обязательно** вызывать `unlock()` после `lock()`
- Иначе мьютекс останется заблокированным навсегда
- Другие потоки будут ждать бесконечно (deadlock)

### Исключения

Если в критической секции произойдет исключение:
- `unlock()` может не быть вызван
- Мьютекс останется заблокированным
- Решение: использовать `std::lock_guard` (следующий пример)

### Производительность

- **Блокировки замедляют** выполнение
- Потоки **ждут** друг друга
- Нужно **минимизировать** время в критической секции

## Преимущества мьютексов

- **Безопасность** - предотвращает race condition
- **Корректность** - гарантирует правильные результаты
- **Простота** - понятный механизм синхронизации
- **Стандартность** - часть стандартной библиотеки C++

## Ограничения

- **Производительность** - блокировки замедляют выполнение
- **Deadlock** - возможны взаимные блокировки
- **Ручное управление** - нужно помнить о lock/unlock
- **Исключения** - могут привести к незаблокированному мьютексу

## Связь с предыдущими примерами

- `11_RaceCondition` - демонстрация проблемы без синхронизации
- `12_Mutex` - решение через мьютексы
- `14_LockGuard` - автоматическое управление мьютексами (следующий пример)

Это демонстрирует переход от проблемы к решению и дальнейшему улучшению.

