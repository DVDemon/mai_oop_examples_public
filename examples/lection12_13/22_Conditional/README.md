# Пример: std::condition_variable (Условная синхронизация)

## Описание

Данный пример демонстрирует использование **`std::condition_variable`** для **условной синхронизации** потоков - механизм, позволяющий потокам ждать выполнения определенного условия, а не просто блокировать доступ к данным.

## Суть примера

### Условная переменная

```cpp
std::mutex mtx;
std::condition_variable cv;
bool ready = false;
```

**Компоненты:**
- **`std::mutex`** - защищает общую переменную `ready`
- **`std::condition_variable`** - позволяет потокам ждать условия
- **`bool ready`** - условие, на которое ждут потоки

### Ожидание условия

```cpp
std::unique_lock<std::mutex> lck(mtx);
while (!ready)
    cv.wait(lck);  // Разблокирует мьютекс и ждет уведомления
```

**Как работает `wait()`:**
1. **Разблокирует мьютекс** автоматически
2. **Блокирует поток** до получения уведомления
3. **Пробуждается** при `notify_one()` или `notify_all()`
4. **Повторно блокирует мьютекс** перед возвратом
5. **Проверяет условие** снова (защита от ложных пробуждений)

### Уведомление потоков

```cpp
std::unique_lock<std::mutex> lck(mtx);
ready = true;
cv.notify_all();  // Пробуждает все ожидающие потоки
```

**Методы уведомления:**
- **`notify_one()`** - пробуждает один поток
- **`notify_all()`** - пробуждает все ожидающие потоки

## Принцип работы

### Синхронизация потоков

```
Потоки (worker):              Основной поток:
    ↓                              ↓
[созданы]                    [работает]
    ↓                              ↓
lck.lock()                    [ждет ввода]
    ↓                              ↓
cv.wait() → [разблокирован]   [пользователь нажал Enter]
    ↓                              ↓
[заблокирован, ждет]          ready = true
    ↓                              ↓
[пробужден]                   cv.notify_all()
    ↓                              ↓
[проверяет ready]             [продолжает]
    ↓                              ↓
[ready == true]               [join()]
    ↓                              ↓
[выполняет работу]            [завершается]
```

### Почему unique_lock, а не lock_guard?

```cpp
std::unique_lock<std::mutex> lck(mtx);  // Можно разблокировать
cv.wait(lck);  // wait() разблокирует мьютекс внутри
```

**Разница:**
- **`std::lock_guard`** - не может быть разблокирован
- **`std::unique_lock`** - может быть разблокирован и заблокирован снова
- **`wait()` требует** возможность разблокировки мьютекса

## Защита от ложных пробуждений

### Цикл while

```cpp
while (!ready)  // Проверка условия в цикле
    cv.wait(lck);
```

**Почему цикл, а не if?**
- Потоки могут **пробудиться случайно** (spurious wakeup)
- Условие может **не выполниться** к моменту пробуждения
- **Цикл гарантирует** проверку условия после пробуждения

## Сравнение с другими механизмами

### std::mutex (12_Mutex)

```cpp
std::lock_guard<std::mutex> lock(mtx);
// Критическая секция
```

**Характеристики:**
- Просто блокирует доступ
- Не ждет условий
- Поток блокируется, даже если условие не выполнено

### std::condition_variable (22_Conditional)

```cpp
std::unique_lock<std::mutex> lck(mtx);
while (!ready)
    cv.wait(lck);  // Ждет условия
```

**Характеристики:**
- Ждет выполнения условия
- Поток разблокирован, пока ждет
- Эффективное использование ресурсов

## Преимущества condition_variable

### Эффективность

- **Не блокирует CPU** - поток спит, пока ждет
- **Разблокирует мьютекс** - другие потоки могут работать
- **Пробуждается только при необходимости** - по уведомлению

### Гибкость

- **Условная синхронизация** - ждет конкретного условия
- **Множественные условия** - можно использовать несколько переменных
- **Producer-Consumer** - идеально для паттернов ожидания данных

### Безопасность

- **Защита от гонок** - мьютекс защищает общие данные
- **Атомарность** - проверка условия и ожидание атомарны
- **Правильная синхронизация** - гарантирует корректный порядок

## Типичные паттерны использования

### Producer-Consumer

```cpp
// Producer
{
    std::lock_guard<std::mutex> lck(mtx);
    queue.push(data);
    cv.notify_one();  // Уведомляет consumer
}

// Consumer
{
    std::unique_lock<std::mutex> lck(mtx);
    while (queue.empty())
        cv.wait(lck);  // Ждет данных
    data = queue.front();
    queue.pop();
}
```

### Барьер синхронизации

```cpp
// Все потоки ждут готовности
while (!ready)
    cv.wait(lck);
// Все потоки начинают одновременно
```

## Важные моменты

### Обязательные компоненты

1. **Мьютекс** - защищает общие данные
2. **Условие** - переменная для проверки
3. **Цикл while** - защита от ложных пробуждений
4. **Уведомление** - `notify_one()` или `notify_all()`

### Правильный порядок

1. Заблокировать мьютекс
2. Проверить условие в цикле
3. Вызвать `wait()` если условие не выполнено
4. Выполнить работу
5. Разблокировать мьютекс (автоматически)

### notify_one() vs notify_all()

- **`notify_one()`** - когда достаточно одного потока
- **`notify_all()`** - когда нужно пробудить все потоки
- **Выбор зависит** от логики приложения

## Связь с предыдущими примерами

- `12_Mutex` - простые блокировки без условий
- `21_Promise` - передача данных через promise/future
- `22_Conditional` - условная синхронизация через condition_variable
- `23_Atomic` - атомарные операции (следующий пример)

Это демонстрирует эволюцию механизмов синхронизации: от простых блокировок к условной синхронизации, позволяющей потокам эффективно ждать выполнения условий.

