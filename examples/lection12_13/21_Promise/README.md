# Пример: std::promise (Явная передача данных между потоками)

## Описание

Данный пример демонстрирует использование **`std::promise`** и **`std::future`** для **явной передачи данных** между потоками - более детальный контроль над асинхронными операциями по сравнению с `std::async`.

## Суть примера

### Создание promise и future

```cpp
std::promise<int> prom;                    // Создание promise
std::future<int> fut = prom.get_future();   // Получение future из promise
```

**Promise-Future пара:**
- **`std::promise`** - создается в одном потоке, устанавливает значение
- **`std::future`** - получается из promise, используется для получения значения
- **Связаны** - один promise соответствует одному future

### Передача future в поток

```cpp
std::thread th1(print_int, std::ref(fut));  // Передача future в поток
```

Future передается в другой поток, который будет ждать значения.

### Установка значения

```cpp
prom.set_value(10);  // Устанавливает значение в promise
```

Когда promise устанавливает значение:
- Future в другом потоке получает его через `get()`
- Поток, ожидающий future, разблокируется

## Принцип работы

### Синхронизация потоков

```
Поток 1 (основной):          Поток 2 (worker):
    ↓                             ↓
promise создан              future получен
    ↓                             ↓
[работает]                  fut.get() → [ждет...]
    ↓                             ↓
prom.set_value(10)          [разблокирован]
    ↓                             ↓
[продолжает]                [получает значение: 10]
```

### Передача исключений

```cpp
prom.set_exception(std::make_exception_ptr(10));
```

Исключения также можно передавать через promise:
- `set_exception()` устанавливает исключение
- `fut.get()` пробрасывает исключение в поток, ожидающий future

## Сравнение с std::async

### std::async (20_Future)

```cpp
auto fut = std::async(is_prime, 444444443);
bool result = fut.get();
```

**Характеристики:**
- Автоматический запуск функции
- Результат возвращается автоматически
- Меньше контроля над процессом

### std::promise (21_Promise)

```cpp
std::promise<int> prom;
auto fut = prom.get_future();
std::thread t(worker, std::ref(fut));
// ... работа ...
prom.set_value(10);
```

**Характеристики:**
- Явное управление потоком
- Явная установка значения
- Больше контроля над синхронизацией

## Преимущества promise

### Гибкость

- **Контроль времени** - можно установить значение в любой момент
- **Множественные источники** - можно выбрать, откуда придет значение
- **Условная установка** - значение может зависеть от условий

### Передача исключений

- **Явная передача** - можно передать исключение явно
- **Обработка ошибок** - удобный способ передачи ошибок между потоками
- **Безопасность** - исключения передаются безопасно

### Сложные сценарии

- **Producer-Consumer** - один поток производит, другой потребляет
- **Условная синхронизация** - синхронизация на основе условий
- **Кастомная логика** - полный контроль над процессом

## Когда использовать

**Используйте `std::promise` когда:**
- Нужен **детальный контроль** над передачей данных
- Значение устанавливается **условно** или **из разных мест**
- Нужна **явная синхронизация** между потоками
- Требуется передача **исключений** между потоками

**Используйте `std::async` когда:**
- Нужно просто **запустить функцию** и получить результат
- **Автоматическое управление** достаточно
- Не нужен детальный контроль

## Важные моменты

### Один promise - один future

- Каждый `promise` может создать только **один** `future`
- `get_future()` можно вызвать **только один раз**
- Повторный вызов приведет к исключению

### Блокировка get()

- `fut.get()` **блокирует** поток до получения значения
- Вызывать `get()` можно **только один раз**
- После `get()` future становится невалидным

### Исключения

- Исключения в promise передаются через `get()`
- Нужно обрабатывать исключения в потоке, получающем значение
- `set_exception()` позволяет передать исключение явно

## Связь с предыдущими примерами

- `20_Future` - высокоуровневый подход через `std::async`
- `21_Promise` - низкоуровневый контроль через `std::promise`
- `22_Conditional` - условная синхронизация (следующий пример)

Это демонстрирует различные уровни абстракции для асинхронного программирования: от простого `async` до детального контроля через `promise`.

