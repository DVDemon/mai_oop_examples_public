# Пример: Предотвращение Deadlock через таймауты

## Описание

Данный пример демонстрирует альтернативный способ предотвращения **deadlock** через использование **`std::timed_mutex`** и **`try_lock_for()`** - обнаружение потенциального deadlock по таймауту и безопасное освобождение ресурсов.

## Суть примера

### Проблема: Deadlock (закомментировано)

```cpp
void DeadLockA() {
    std::lock_guard<std::mutex> lockA(resource_A);  // Блокирует A
    // ...
    std::lock_guard<std::mutex> lockB(resource_B);  // Ждет B
}

void DeadLockB() {
    std::lock_guard<std::mutex> lockB(resource_B);  // Блокирует B
    // ...
    std::lock_guard<std::mutex> lockA(resource_A);  // Ждет A → Deadlock!
}
```

Классический deadlock: разные потоки блокируют мьютексы в разном порядке.

### Решение: timed_mutex с таймаутом

```cpp
void NotLockA() {
    resource_AT.lock();  // Блокирует A
    
    if (resource_BT.try_lock_for(std::chrono::milliseconds(2000))) {
        // Успешно заблокировал B
        resource_BT.unlock();
    } else {
        // Таймаут - возможен deadlock!
        print() << "A: Deadlock detected!!!!" << std::endl;
    }
    resource_AT.unlock();  // Освобождает A
}
```

## Принцип работы

### std::timed_mutex

`std::timed_mutex` - мьютекс с поддержкой таймаутов:
- Обычные методы: `lock()`, `unlock()`
- С таймаутом: `try_lock_for(duration)` - пытается заблокировать в течение указанного времени
- Возвращает `true` при успехе, `false` при таймауте

### try_lock_for()

```cpp
if (resource_BT.try_lock_for(std::chrono::milliseconds(2000))) {
    // Блокировка успешна
} else {
    // Таймаут - обнаружение потенциального deadlock
}
```

**Преимущество:** Поток не ждет бесконечно, а получает сигнал о проблеме.

## Обнаружение deadlock

### Стратегия

1. **Блокируем первый ресурс** обычным способом
2. **Пытаемся заблокировать второй** с таймаутом
3. **Если таймаут** - освобождаем первый ресурс и сообщаем о проблеме
4. **Избегаем deadlock** - поток не зависает навсегда

### Визуализация

```
Поток A: lock(AT) → try_lock_for(BT, 2s) → ⏳ ждет...
Поток B: lock(BT) → try_lock_for(AT, 2s) → ⏳ ждет...

Через 2 секунды:
Поток A: таймаут! → unlock(AT) → "Deadlock detected!"
Поток B: таймаут! → unlock(BT) → "Deadlock detected!"

Результат: Deadlock обнаружен и предотвращен!
```

## Потокобезопасный вывод

```cpp
struct print : std::stringstream {
    ~print() {
        static std::mutex mtx;
        std::lock_guard<std::mutex> lck(mtx);
        std::cout << this->str();
    }
};
```

Класс `print` обеспечивает потокобезопасный вывод:
- Использует статический мьютекс для синхронизации
- В деструкторе автоматически блокирует вывод
- Предотвращает перемешивание вывода от разных потоков

## Сравнение подходов

### std::lock() (15_Deadlock)

```cpp
std::lock(foo, bar);  // Атомарная блокировка
```

**Преимущества:**
- Гарантированно предотвращает deadlock
- Нет таймаутов - работает сразу или не работает

### try_lock_for() (17_DeadLock2)

```cpp
if (mtx.try_lock_for(timeout)) {
    // Успех
} else {
    // Обнаружение deadlock
}
```

**Преимущества:**
- Обнаружение потенциального deadlock
- Возможность обработки ситуации
- Не блокирует поток навсегда

## Когда использовать

### std::lock()

- Нужна гарантированная блокировка всех мьютексов
- Можно ждать бесконечно
- Простота важнее обнаружения проблем

### try_lock_for()

- Нужно обнаружить deadlock
- Требуется обработка таймаутов
- Важна отзывчивость системы
- Нужна возможность отката при неудаче

## Ограничения

- **Не предотвращает deadlock** - только обнаруживает его
- **Требует обработки** - нужно правильно обработать таймаут
- **Сложнее** - больше кода для обработки ситуаций
- **Производительность** - таймауты могут замедлить выполнение

## Связь с предыдущими примерами

- `15_Deadlock` - предотвращение deadlock через `std::lock()`
- `17_DeadLock2` - обнаружение deadlock через таймауты
- `16_SharedLock` - оптимизация для чтения/записи

Это демонстрирует различные стратегии работы с deadlock: предотвращение и обнаружение.

