# Пример: Захват переменных и mutable в лямбда-выражениях

## Описание

Данный пример демонстрирует **захват переменных по значению** в лямбда-выражениях и использование ключевого слова **`mutable`** для изменения захваченных переменных.

## Суть примера

### Лямбда с захватом и mutable

```cpp
int count = 0;

auto lambda = [count]() mutable {
    std::cout << "Count:" << count << std::endl;
    return ++count;
};
```

### Ключевые моменты

1. **`[count]`** - захват переменной `count` **по значению** (создается копия)
2. **`mutable`** - позволяет изменять захваченную по значению переменную внутри лямбды
3. **Изоляция** - изменения в `count` внутри лямбды **не влияют** на оригинальную переменную

## Важное различие

### С mutable

```cpp
int count = 0;
auto lambda = [count]() mutable {
    return ++count;  // Можно изменять копию
};
lambda();  // count в лямбде = 1
lambda();  // count в лямбде = 2
// Но оригинальная count все еще = 0!
```

### Без mutable

```cpp
int count = 0;
auto lambda = [count]() {
    return ++count;  // ОШИБКА КОМПИЛЯЦИИ!
    // Захваченные по значению переменные нельзя изменять
};
```

## Результат выполнения

```cpp
for (int i = 0; i < 10; i++)
    elements.push_back(lambda());
```

Результат: `1 2 3 4 5 6 7 8 9 10`

Но `count` в основной функции остается `0`, потому что:
- Лямбда работает с **копией** переменной
- Изменения в копии не влияют на оригинал

## Захват по значению vs по ссылке

| Захват по значению `[count]` | Захват по ссылке `[&count]` |
|-------------------------------|------------------------------|
| Создается копия переменной | Используется ссылка на оригинал |
| Изменения не влияют на оригинал | Изменения влияют на оригинал |
| Нужен `mutable` для изменения | Можно изменять без `mutable` |
| Безопаснее (изоляция) | Может быть опасно (время жизни) |

## Когда использовать mutable

`mutable` нужен когда:
- Захватываете переменную **по значению**
- Хотите **изменять** ее внутри лямбды
- Нужна **изоляция** от оригинальной переменной

## Пример использования

В данном примере лямбда используется как **счетчик с состоянием**:
- Каждый вызов увеличивает внутренний счетчик
- Состояние хранится внутри лямбды
- Оригинальная переменная `count` не изменяется

Это полезно для:
- Создания генераторов последовательностей
- Сохранения состояния между вызовами
- Изоляции логики от внешнего контекста

## Связь с предыдущими примерами

- `02_Lambda` - базовые лямбды с захватом
- `03_LambdaReturn` - лямбды с возвращаемым типом
- `04_LambdaCapture` - детальное изучение захвата и `mutable`

Это демонстрирует эволюцию от простых лямбд к более сложным с управлением состоянием.

