# Пример: Безопасное управление потоками (RAII)

## Описание

Данный пример демонстрирует создание класса **`Scoped_Thread`** для безопасного управления потоками по принципу **RAII (Resource Acquisition Is Initialization)** - автоматическое освобождение ресурсов в деструкторе.

## Суть примера

### Проблема с std::thread

Обычный `std::thread` требует явного вызова `join()`:
- Если забыть `join()` - программа может завершиться до окончания потоков
- Если поток уже завершен - `join()` вызовет исключение
- Нужно помнить о синхронизации вручную

### Решение: Scoped_Thread

```cpp
class Scoped_Thread {
    std::thread t;
public:
    Scoped_Thread(std::thread&& t_) : t(std::move(t_)) {
        if (!t.joinable()) throw std::logic_error("No thread");
    }
    
    ~Scoped_Thread() {
        if (t.joinable()) t.join();  // Автоматический join в деструкторе
    }
};
```

**Принцип RAII:**
- Ресурс (поток) захватывается в конструкторе
- Ресурс освобождается в деструкторе
- Гарантированное освобождение даже при исключениях

## Преимущества Scoped_Thread

- **Автоматическая синхронизация** - `join()` вызывается автоматически
- **Безопасность** - невозможно забыть вызвать `join()`
- **Исключения** - работает корректно даже при исключениях
- **Простота** - не нужно помнить о ручном управлении

## Сравнение подходов

### Race 1: Scoped_Thread (автоматический join)

```cpp
for (int i = 0; i < 300; i++) {
    Scoped_Thread t(std::move(std::thread(my_function)));
    // join() вызывается автоматически в деструкторе
}
```

**Преимущества:** Безопасно, автоматически

### Race 2: Последовательное выполнение

```cpp
for (int i = 0; i < 300; i++) {
    my_function();  // Без потоков
}
```

**Характеристики:** Медленно, но просто

### Race 3: Ручное управление потоками

```cpp
std::vector<std::thread*> threads;
for (int i = 0; i < 300; i++) 
    threads.push_back(new std::thread(my_function));

for (auto tt : threads) {
    tt->join();
    delete tt;
}
```

**Проблемы:** 
- Нужно помнить о `join()` и `delete`
- Утечки памяти при исключениях
- Сложность управления

### Race 4: Scoped_Thread в векторе

```cpp
std::vector<Scoped_Thread> threads;
for (int i = 0; i < 300; i++) 
    threads.push_back(Scoped_Thread(std::thread(my_function)));
// Все потоки автоматически join() при уничтожении вектора
```

**Преимущества:** Безопасно, автоматически, масштабируемо

### Race 5: Оптимизация по количеству ядер

```cpp
int hc = std::thread::hardware_concurrency();
// Создание потоков порциями по количеству ядер
```

**Преимущества:** Оптимальное использование ресурсов процессора

## hardware_concurrency()

```cpp
int hc = std::thread::hardware_concurrency();
```

Возвращает количество **аппаратных потоков** процессора:
- Оптимальное количество потоков для параллельных задач
- Помогает избежать избыточного создания потоков
- Улучшает производительность

## Принцип RAII

**Resource Acquisition Is Initialization:**
- Ресурс захватывается при создании объекта
- Ресурс освобождается при уничтожении объекта
- Гарантирует безопасное управление ресурсами

В данном случае:
- **Захват**: получение потока в конструкторе
- **Освобождение**: `join()` в деструкторе

## Когда использовать Scoped_Thread

- **Автоматическое управление** - когда нужна гарантия `join()`
- **Безопасность** - когда важна защита от забытого `join()`
- **Исключения** - когда нужна корректная работа при исключениях
- **Простота** - когда хочется упростить код

## Связь с предыдущими примерами

- `08_Thread` - базовое создание потоков (ручной `join()`)
- `09_ThreadParameter` - передача параметров в потоки
- `10_ScopedThread` - безопасное управление потоками через RAII

Это демонстрирует эволюцию от ручного управления к автоматическому и безопасному.

