# Пример: Рекурсивные мьютексы (Recursive Mutex)

## Описание

Данный пример демонстрирует разницу между **обычным мьютексом** (`std::mutex`) и **рекурсивным мьютексом** (`std::recursive_mutex`) при рекурсивных вызовах функций, которые блокируют один и тот же мьютекс.

## Суть примера

### Рекурсивный вызов с блокировкой

```cpp
void threadFunction(MUTEX *lock) {
    lock->lock();                    // Первая блокировка
    threadFunction2(lock);           // Вызов другой функции
    lock->unlock();
}

void threadFunction2(MUTEX *lock) {
    lock->lock();                    // Попытка второй блокировки
    // ...
    lock->unlock();
}
```

Одна функция вызывает другую, и обе пытаются заблокировать **один и тот же мьютекс**.

## Проблема с обычным мьютексом

### std::mutex - deadlock

```cpp
std::mutex lock2;
std::thread t2(threadFunction<std::mutex>, &lock2);
// Результат: бесконечное ожидание (deadlock)
```

**Что происходит:**
1. `threadFunction` блокирует мьютекс
2. Вызывает `threadFunction2`, которая пытается заблокировать **тот же мьютекс**
3. Мьютекс уже заблокирован **тем же потоком**
4. Поток ждет сам себя → **deadlock**

### Визуализация проблемы

```
Поток: lock() → [владеет мьютексом]
       ↓
       вызывает threadFunction2()
       ↓
       lock() → [пытается заблокировать снова]
       ↓
       ⚠️ Мьютекс уже заблокирован этим потоком!
       ↓
       Бесконечное ожидание (deadlock)
```

## Решение: recursive_mutex

### std::recursive_mutex - работает

```cpp
std::recursive_mutex lock1;
std::thread t1(threadFunction<std::recursive_mutex>, &lock1);
// Результат: работает корректно
```

**Принцип работы:**
- **Рекурсивный мьютекс** позволяет **одному потоку** блокировать его **несколько раз**
- Каждый `lock()` увеличивает счетчик блокировок
- Каждый `unlock()` уменьшает счетчик
- Мьютекс освобождается только когда счетчик = 0

### Как это работает

```
Поток: lock() → счетчик = 1
       ↓
       вызывает threadFunction2()
       ↓
       lock() → счетчик = 2 (тот же поток!)
       ↓
       unlock() → счетчик = 1
       ↓
       unlock() → счетчик = 0 (мьютекс свободен)
```

## Сравнение

| Характеристика | `std::mutex` | `std::recursive_mutex` |
|----------------|--------------|------------------------|
| **Рекурсивная блокировка** | ❌ Deadlock | ✅ Работает |
| **Производительность** | Быстрее | Медленнее (счетчик) |
| **Использование** | Обычные случаи | Рекурсивные вызовы |
| **Сложность** | Проще | Сложнее (нужно считать unlock) |

## Когда использовать recursive_mutex

**Используйте `std::recursive_mutex` когда:**
- Функции рекурсивно вызывают друг друга
- Одна функция вызывает другую, и обе нуждаются в блокировке
- Сложно реорганизовать код для избежания рекурсии

**Избегайте `std::recursive_mutex` когда:**
- Можно реорганизовать код без рекурсии
- Нужна максимальная производительность
- Есть риск забыть вызвать `unlock()` нужное количество раз

## Важные моменты

### Счетчик блокировок

Рекурсивный мьютекс ведет **счетчик блокировок**:
- Каждый `lock()` увеличивает счетчик
- Каждый `unlock()` уменьшает счетчик
- **Важно**: вызвать `unlock()` столько раз, сколько было `lock()`

### Производительность

- `recursive_mutex` **медленнее** обычного мьютекса
- Нужно поддерживать счетчик блокировок
- Используйте только когда действительно нужно

### Альтернативы

Вместо `recursive_mutex` можно:
- Реорганизовать код без рекурсии
- Использовать отдельные мьютексы для разных уровней
- Применить другие паттерны синхронизации

## Связь с предыдущими примерами

- `12_Mutex` - обычные мьютексы для простых случаев
- `13_MutexRecursive` - рекурсивные мьютексы для сложных случаев
- `14_LockGuard` - автоматическое управление мьютексами (следующий пример)

Это демонстрирует различные типы мьютексов для разных сценариев использования.

