# Пример: Deadlock (Взаимная блокировка) и его предотвращение

## Описание

Данный пример демонстрирует проблему **deadlock (взаимной блокировки)** - ситуацию, когда два или более потока блокируют друг друга, ожидая освобождения ресурсов, и решение через **`std::lock()`** для одновременной блокировки нескольких мьютексов.

## Суть примера

### Проблема: Deadlock

В закомментированном коде показан классический deadlock:

```cpp
// Поток 1
a.lock();
std::this_thread::sleep_for(...);
b.lock();  // Ждет, пока поток 2 освободит b

// Поток 2
b.lock();
a.lock();  // Ждет, пока поток 1 освободит a
```

**Что происходит:**
- Поток 1 блокирует `a`, затем пытается заблокировать `b`
- Поток 2 блокирует `b`, затем пытается заблокировать `a`
- Оба потока ждут друг друга → **deadlock**

### Визуализация deadlock

```
Поток 1: lock(a) → [владеет a] → пытается lock(b) → ⏳ ждет...
Поток 2: lock(b) → [владеет b] → пытается lock(a) → ⏳ ждет...

Результат: оба потока ждут бесконечно!
```

## Решение: std::lock()

### Одновременная блокировка

```cpp
void task_a() {
    std::lock(foo, bar);  // Одновременная блокировка (предотвращает deadlock)
    std::unique_lock<std::mutex> lck1(foo, std::adopt_lock);
    std::unique_lock<std::mutex> lck2(bar, std::adopt_lock);
}
```

**`std::lock()`** блокирует **все мьютексы атомарно**:
- Использует специальный алгоритм для предотвращения deadlock
- Блокирует все мьютексы или ни одного
- Гарантирует отсутствие deadlock

### std::unique_lock с adopt_lock

```cpp
std::unique_lock<std::mutex> lck1(foo, std::adopt_lock);
```

**`std::adopt_lock`** означает:
- Мьютекс **уже заблокирован**
- `unique_lock` принимает владение существующей блокировкой
- В деструкторе автоматически вызовет `unlock()`

### std::unique_lock с defer_lock

```cpp
std::unique_lock<std::mutex> lck1(bar, std::defer_lock);
std::lock(lck1, lck2);  // Блокировка через unique_lock
```

**`std::defer_lock`** означает:
- Мьютекс **не блокируется** при создании
- Блокировка выполняется позже через `std::lock()`
- Позволяет использовать `std::lock()` с `unique_lock`

## Принцип работы std::lock()

`std::lock()` использует алгоритм предотвращения deadlock:
1. Пытается заблокировать все мьютексы
2. Если не удалось - **освобождает все** уже заблокированные
3. Повторяет попытку
4. Гарантирует атомарную блокировку всех мьютексов

## Сравнение подходов

### Проблемный подход (deadlock)

```cpp
// Поток 1: a.lock() → b.lock()
// Поток 2: b.lock() → a.lock()
// Результат: deadlock!
```

**Проблема:** Разный порядок блокировки в разных потоках

### Решение через std::lock()

```cpp
// Оба потока используют std::lock(foo, bar)
// Результат: безопасно, без deadlock
```

**Преимущество:** Атомарная блокировка предотвращает deadlock

## Правила предотвращения deadlock

1. **Всегда блокировать в одном порядке** - если все потоки блокируют мьютексы в одинаковом порядке, deadlock невозможен
2. **Использовать std::lock()** - для блокировки нескольких мьютексов
3. **Избегать вложенных блокировок** - минимизировать количество одновременно заблокированных мьютексов
4. **Использовать таймауты** - `try_lock_for()` вместо бесконечного ожидания

## std::unique_lock vs std::lock_guard

| Характеристика | `std::lock_guard` | `std::unique_lock` |
|----------------|-------------------|-------------------|
| **Гибкость** | Фиксированная блокировка | Гибкое управление |
| **adopt_lock** | ✅ Поддерживает | ✅ Поддерживает |
| **defer_lock** | ❌ Не поддерживает | ✅ Поддерживает |
| **try_lock** | ❌ Не поддерживает | ✅ Поддерживает |
| **Производительность** | Быстрее | Медленнее (больше функций) |

## Связь с предыдущими примерами

- `12_Mutex` - базовое использование мьютексов
- `14_LockGuard` - автоматическое управление одним мьютексом
- `15_Deadlock` - проблема deadlock и решение через `std::lock()`
- `17_DeadLock2` - другие способы предотвращения deadlock (следующий пример)

Это демонстрирует важность правильной синхронизации при работе с несколькими мьютексами.

