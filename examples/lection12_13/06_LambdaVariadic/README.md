# Пример: Variadic templates и композиция функций

## Описание

Данный пример демонстрирует использование **variadic templates** (шаблонов с переменным количеством параметров) для создания **композиции функций** через лямбда-выражения.

## Суть примера

### Функция композиции

```cpp
template <class T, class ...Ts>
auto concat(T t, Ts ...ts) {
    if constexpr (sizeof...(ts) > 0) {
        return [t,ts...](auto ...parameters) {
            return t(concat(ts...)(parameters...));
        };
    } else {
        return t;  // Базовый случай рекурсии
    }
}
```

### Применение

```cpp
auto plus   = [](int a, int b) { return a + b; };
auto twice  = [](int i) { return i * 2; };
auto thrice = [](int i) { return i * 3; };

auto combined = concat(twice, thrice, plus);
std::cout << combined(2, 3) << std::endl;
// Результат: twice(thrice(plus(2, 3)))
```

## Принцип работы

### Variadic templates

- `T` - первый тип (первая функция)
- `Ts...` - пакет типов (остальные функции)
- `sizeof...(ts)` - количество параметров в пакете

### Рекурсивная композиция

1. **Базовый случай**: если функций больше нет (`sizeof...(ts) == 0`), возвращается последняя функция
2. **Рекурсивный случай**: создается лямбда, которая:
   - Захватывает первую функцию `t` и остальные `ts...`
   - Принимает variadic параметры `auto ...parameters`
   - Вызывает `t` с результатом рекурсивной композиции остальных функций

### Захват variadic параметров

```cpp
[t, ts...](auto ...parameters)
```

- `[t, ts...]` - захват первой функции и пакета функций
- `(auto ...parameters)` - variadic параметры (любое количество аргументов)

## Выполнение композиции

```cpp
concat(twice, thrice, plus)(2, 3)
```

Выполняется справа налево:
1. `plus(2, 3)` → `5`
2. `thrice(5)` → `15`
3. `twice(15)` → `30`

Эквивалентно: `twice(thrice(plus(2, 3)))`

## if constexpr

```cpp
if constexpr (sizeof...(ts) > 0) {
    // Компилируется только если есть еще функции
}
```

`if constexpr` - условная компиляция на этапе компиляции:
- Проверка выполняется компилятором
- Неподходящая ветка не компилируется
- Позволяет использовать разные возвращаемые типы

## Композиция функций

**Композиция функций** - применение одной функции к результату другой:
- `f(g(x))` - композиция `f` и `g`
- В данном примере: композиция произвольного количества функций

## Преимущества

- **Гибкость** - можно комбинировать любое количество функций
- **Типобезопасность** - проверка типов на этапе компиляции
- **Универсальность** - работает с функциями разных сигнатур
- **Выразительность** - компактный синтаксис для композиции

## Ограничения

- Функции должны быть **совместимы** по типам
- Результат одной функции должен быть входом для следующей
- Рекурсивная природа может ограничивать глубину композиции

## Связь с предыдущими примерами

- `02_Lambda` - базовые лямбды
- `03_LambdaReturn` - возвращаемые типы
- `04_LambdaCapture` - захват переменных
- `05_LambdaGen` - лямбда-генераторы
- `06_LambdaVariadic` - variadic templates и композиция функций

Это демонстрирует продвинутое использование лямбд с шаблонами и метапрограммированием.

