# Пример: Потокобезопасный стек (Thread-Safe Stack)

## Описание

Данный пример демонстрирует создание **потокобезопасного стека** - обертки над `std::stack` с синхронизацией через мьютексы для безопасного использования в многопоточных программах.

## Суть примера

### Проблема с обычным std::stack

Обычный `std::stack` **не является потокобезопасным**:
- Одновременный доступ из разных потоков приводит к race condition
- Нужна синхронизация для всех операций

### Решение: thread_safe_stack

```cpp
template <typename T>
class thread_safe_stack {
private:
    std::stack<T> data;
    mutable std::mutex m;  // Мьютекс для синхронизации

public:
    void push(T new_value) {
        std::lock_guard<std::mutex> lock(m);
        data.push(new_value);
    }
    
    std::shared_ptr<T> pop() {
        std::lock_guard<std::mutex> lock(m);
        if (data.empty()) throw empty_stack();
        std::shared_ptr<T> const res(new T(data.top()));
        data.pop();
        return res;
    }
};
```

## Принцип работы

### Синхронизация операций

Все операции защищены мьютексом:
- **`push()`** - добавление элемента (блокировка на время операции)
- **`pop()`** - извлечение элемента (блокировка на время операции)
- **`empty()`** - проверка пустоты (блокировка на время проверки)

### Два варианта pop()

**Вариант 1: Возврат shared_ptr**
```cpp
std::shared_ptr<T> pop() {
    std::lock_guard<std::mutex> lock(m);
    if (data.empty()) throw empty_stack();
    std::shared_ptr<T> const res(new T(data.top()));
    data.pop();
    return res;
}
```

**Вариант 2: Запись в параметр**
```cpp
void pop(T &value) {
    std::lock_guard<std::mutex> lock(m);
    if (data.empty()) throw empty_stack();
    value = data.top();
    data.pop();
}
```

Оба варианта безопасны, но первый более гибкий (возвращает указатель).

## Проблема race condition между операциями

### Потенциальная проблема

```cpp
if (!stack.empty()) {  // Проверка
    // Другой поток может изменить стек здесь!
    stack.pop(value);  // Может быть пустым!
}
```

**Проблема:** Между проверкой `empty()` и вызовом `pop()` другой поток может изменить стек.

### Решение в thread_safe_stack

В `pop()` проверка и извлечение **атомарны** (внутри одной блокировки):
```cpp
std::lock_guard<std::mutex> lock(m);  // Блокировка
if (data.empty()) throw empty_stack();  // Проверка
// ... извлечение ...  // Всё под одной блокировкой
```

## Особенности реализации

### mutable мьютекс

```cpp
mutable std::mutex m;
```

`mutable` позволяет блокировать мьютекс в `const` методах (например, `empty()`):
- Мьютекс не изменяет логическое состояние объекта
- Нужен только для синхронизации

### Конструктор копирования

```cpp
thread_safe_stack(const thread_safe_stack &other) {
    std::lock_guard<std::mutex> lock(other.m);  // Блокируем исходный стек
    data = other.data;
}
```

Блокирует **исходный** стек при копировании для безопасности.

## Преимущества

- **Потокобезопасность** - все операции синхронизированы
- **Простота использования** - интерфейс похож на `std::stack`
- **Безопасность** - защита от race condition
- **Гибкость** - два варианта `pop()` для разных случаев

## Ограничения

- **Производительность** - блокировки замедляют выполнение
- **Не все операции атомарны** - проверка `empty()` и `pop()` отдельно не атомарны
- **Исключения** - нужно обрабатывать `empty_stack()`

## Применение

Потокобезопасный стек полезен для:
- **Producer-Consumer** паттернов - один поток добавляет, другой извлекает
- **Распределения задач** - пул задач в стеке
- **Отката операций** - стек для undo/redo в многопоточных приложениях

## Связь с предыдущими примерами

- `11_RaceCondition` - демонстрация проблемы race condition
- `12_Mutex` - решение через мьютексы
- `14_LockGuard` - автоматическое управление мьютексами
- `18_Stack` - практическое применение для создания потокобезопасной структуры данных

Это демонстрирует применение изученных техник синхронизации для создания безопасных структур данных.

