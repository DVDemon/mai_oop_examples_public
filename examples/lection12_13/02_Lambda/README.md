# Пример: Лямбда-выражения (Lambda Expressions)

## Описание

Данный пример демонстрирует использование **лямбда-выражений** в C++ - анонимных функций, которые можно определять прямо в месте использования.

## Суть примера

### Лямбда-выражение

```cpp
auto lambda = [elements](auto i) {
    std::cout << i << " " << elements.size() << std::endl;
    return 10;
};
```

### Синтаксис лямбды

```
[захват](параметры) -> возвращаемый_тип { тело }
```

В данном примере:
- `[elements]` - **захват по значению** - копирует переменную `elements` в лямбду
- `(auto i)` - параметр функции (используется `auto` для обобщенного типа)
- `{ ... }` - тело функции

### Функтор (альтернатива)

```cpp
class MyLambda {
public:
    void operator()(int i) const {
        std::cout << i << " ";
    }
};
```

Функтор - это класс с перегруженным `operator()`, который можно вызывать как функцию.

## Размер объектов

Пример демонстрирует, что:
- **Лямбда** хранит захваченные переменные внутри себя (размер зависит от захваченных данных)
- **Функтор** может быть пустым (размер минимальный, если нет данных-членов)

```cpp
std::cout << "sizeof lambda:" << sizeof(lambda) << std::endl;  // Зависит от elements
std::cout << "sizeof functor:" << sizeof(functor) << std::endl; // Минимальный размер
```

## Захват переменных

Лямбда может захватывать переменные из окружающей области видимости:

- `[elements]` - захват по значению (копия)
- `[&elements]` - захват по ссылке
- `[=]` - захват всех переменных по значению
- `[&]` - захват всех переменных по ссылке
- `[elements, &other]` - смешанный захват

## Преимущества лямбд

- **Компактность** - можно определить прямо в месте использования
- **Читаемость** - логика видна сразу, не нужно искать определение функции
- **Захват контекста** - автоматический доступ к переменным из окружающей области
- **Удобство** - не нужно создавать отдельный класс-функтор

## Сравнение с функтором

| Лямбда | Функтор |
|--------|---------|
| Анонимная функция | Именованный класс |
| Захват переменных автоматически | Нужно хранить данные в классе |
| Компактный синтаксис | Более многословный |
| Размер зависит от захвата | Размер фиксирован |

## Связь с предыдущим примером

В отличие от `01_ParameterFunction`, где функции определялись отдельно, лямбды позволяют:
- Определять функции прямо в месте использования
- Захватывать переменные из окружающего контекста
- Использовать более компактный синтаксис

## Применение

Лямбды особенно полезны для:
- Алгоритмов STL (`std::for_each`, `std::transform`, и т.д.)
- Обработчиков событий
- Предикатов и компараторов
- Асинхронных операций

