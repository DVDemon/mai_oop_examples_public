# Пример: Практическое применение лямбда-выражений

## Описание

Данный пример демонстрирует **практическое применение лямбда-выражений** для фильтрации и обработки данных с использованием шаблонных функций.

## Суть примера

### Шаблонная функция фильтрации

```cpp
template <class T, class FILTER>
void transform(const std::vector<T> &input,
              std::vector<T> &output, FILTER filter) {
    for (auto a : input)
        if (filter(a))
            output.push_back(a);
}
```

Функция `transform` фильтрует элементы по предикату (лямбде):
- Принимает любой тип `T` и любой вызываемый объект `FILTER`
- Применяет фильтр к каждому элементу
- Добавляет прошедшие фильтр элементы в выходной вектор

### Шаблонная функция применения действия

```cpp
template <class T, class ACTION>
void applay(const std::vector<T> &input, ACTION action) {
    for (auto a : input)
        action(a);
}
```

Функция `applay` применяет действие (лямбду) к каждому элементу:
- Принимает любой тип `T` и любой вызываемый объект `ACTION`
- Выполняет действие для каждого элемента

## Применение

### Фильтрация по предикату

```cpp
transform(persons, females, [](const Person &person) {
    return person.sex == person_sex_t::Female;
});
```

Лямбда используется как **предикат** (функция, возвращающая bool):
- Проверяет условие для каждого элемента
- Возвращает `true` для элементов, проходящих фильтр

### Применение действия

```cpp
applay(females, [](const Person &person) {
    std::cout << "[" << person.name << "]" << std::endl;
});
```

Лямбда используется как **действие** (функция без возвращаемого значения):
- Выполняет операцию над каждым элементом
- В данном случае - выводит имя

## Преимущества подхода

### Гибкость

- **Любые типы данных** - шаблоны работают с любыми типами
- **Любые условия** - можно задать любой предикат через лямбду
- **Любые действия** - можно выполнить любое действие через лямбду

### Читаемость

- **Локальная логика** - предикат и действие видны прямо в месте использования
- **Выразительность** - код ясно показывает, что происходит
- **Компактность** - не нужно создавать отдельные функции

### Переиспользование

- **Универсальные функции** - `transform` и `applay` работают с любыми типами
- **Разные предикаты** - можно легко изменить условие фильтрации
- **Разные действия** - можно легко изменить операцию

## Сравнение с STL

В STL есть аналогичные функции:
- `std::copy_if` - аналог `transform` (фильтрация)
- `std::for_each` - аналог `applay` (применение действия)

Данный пример демонстрирует, как можно реализовать подобную функциональность самостоятельно.

## Паттерны проектирования

Пример демонстрирует элементы:
- **Strategy Pattern** - лямбда как стратегия фильтрации/действия
- **Template Method** - шаблонная функция определяет алгоритм, лямбда - детали

## Связь с предыдущими примерами

- `01_ParameterFunction` - передача функций как параметров
- `02_Lambda` - базовые лямбды
- `03_LambdaReturn` - возвращаемые типы
- `04_LambdaCapture` - захват переменных
- `05_LambdaGen` - лямбда-генераторы
- `06_LambdaVariadic` - variadic templates
- `07_LambdaExample` - практическое применение в реальных задачах

Это демонстрирует переход от изучения синтаксиса к практическому применению лямбд.

