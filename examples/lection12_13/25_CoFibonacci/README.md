# Пример: Корутины - Генератор чисел Фибоначчи (Бесконечная последовательность)

## Описание

Данный пример демонстрирует использование **корутин** для генерации **бесконечной последовательности** чисел Фибоначчи - показывает, как корутины эффективно работают с последовательностями, которые теоретически бесконечны.

## Суть примера

### Генератор Фибоначчи

```cpp
FibonacciGenerator fibonacci() {
    int a = 0, b = 1;
    while (true) {  // Бесконечный цикл!
        co_yield b;
        int next = a + b;
        a = b;
        b = next;
    }
}
```

**Особенности:**
- **Бесконечный цикл** - корутина никогда не завершается сама
- **Сохранение состояния** - переменные `a` и `b` сохраняются между вызовами
- **Ленивое вычисление** - каждое число вычисляется только когда нужно

### Использование

```cpp
auto gen = fibonacci();

for (int i = 0; i < 10; ++i) {
    gen.move_next();
    std::cout << gen.current_value() << std::endl;
}
```

**Результат:** Первые 10 чисел Фибоначчи: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55

## Принцип работы

### Сохранение состояния

```
Первый вызов:
    fibonacci() → a=0, b=1
    ↓
    co_yield b (1) → приостановка
    ↓
    [состояние: a=0, b=1 сохранено]

Второй вызов:
    move_next() → возобновление
    ↓
    next = a + b = 0 + 1 = 1
    a = b = 1
    b = next = 1
    ↓
    co_yield b (1) → приостановка
    ↓
    [состояние: a=1, b=1 сохранено]

Третий вызов:
    move_next() → возобновление
    ↓
    next = a + b = 1 + 1 = 2
    a = b = 1
    b = next = 2
    ↓
    co_yield b (2) → приостановка
    ↓
    [состояние: a=1, b=2 сохранено]

...и так далее
```

### Ключевое отличие от обычных функций

**Обычная функция:**
```cpp
int fibonacci() {
    static int a = 0, b = 1;
    int next = a + b;
    a = b;
    b = next;
    return b;
}
```

**Проблемы:**
- Использует статические переменные (не thread-safe)
- Нет контроля над приостановкой
- Невозможно создать несколько независимых генераторов

**Корутина:**
```cpp
FibonacciGenerator fibonacci() {
    int a = 0, b = 1;  // Локальные переменные!
    while (true) {
        co_yield b;
        // ...
    }
}
```

**Преимущества:**
- Локальные переменные (безопасно)
- Каждый генератор имеет свое состояние
- Можно создать несколько независимых генераторов

## Сравнение с предыдущим примером

### 24_CoSimple - Конечная последовательность

```cpp
Generator sequence(int start, int end) {
    for (int i = start; i <= end; ++i) {
        co_yield i;
    }
    // Корутина завершается автоматически
}
```

**Характеристики:**
- Конечная последовательность
- Завершается автоматически
- `move_next()` вернет `false` после последнего элемента

### 25_CoFibonacci - Бесконечная последовательность

```cpp
FibonacciGenerator fibonacci() {
    int a = 0, b = 1;
    while (true) {
        co_yield b;
        // ...
    }
    // Корутина никогда не завершается сама
}
```

**Характеристики:**
- Бесконечная последовательность
- Никогда не завершается автоматически
- `move_next()` всегда вернет `true` (пока не уничтожена)
- Потребитель контролирует, сколько значений получить

## Преимущества для бесконечных последовательностей

### Эффективность памяти

**Традиционный подход (невозможен для бесконечной последовательности):**
```cpp
std::vector<int> fibonacci(int count) {
    std::vector<int> result;
    int a = 0, b = 1;
    for (int i = 0; i < count; ++i) {
        result.push_back(b);
        int next = a + b;
        a = b;
        b = next;
    }
    return result;  // Хранит все значения
}
```

**Проблемы:**
- Нужно знать количество заранее
- Хранит все значения в памяти
- Неэффективно для больших последовательностей

**Корутины:**
```cpp
auto gen = fibonacci();
// Получаем только нужное количество значений
for (int i = 0; i < 10; ++i) {
    gen.move_next();
    // Используем значение
}
```

**Преимущества:**
- Не нужно знать количество заранее
- Хранит только текущее состояние (a, b)
- Эффективно для любых размеров

### Гибкость использования

```cpp
// Первые 10 чисел
auto gen1 = fibonacci();
for (int i = 0; i < 10; ++i) {
    gen1.move_next();
    std::cout << gen1.current_value() << " ";
}

// Следующие 5 чисел (новый генератор)
auto gen2 = fibonacci();
for (int i = 0; i < 15; ++i) {
    gen2.move_next();
    if (i >= 10)  // Пропускаем первые 10
        std::cout << gen2.current_value() << " ";
}
```

**Возможности:**
- Можно получить любое количество значений
- Можно создать несколько независимых генераторов
- Можно остановить в любой момент

## Типичные применения бесконечных генераторов

### Математические последовательности

- Числа Фибоначчи
- Простые числа
- Последовательности Коллатца
- Ряды Тейлора

### Потоки данных

- Чтение из файла построчно
- Сетевые потоки
- Генерация случайных чисел
- Парсинг токенов

### Итераторы

- Обход бесконечных структур
- Ленивая фильтрация
- Трансформация данных на лету

## Важные моменты

### Управление жизнью бесконечной корутины

```cpp
auto gen = fibonacci();

// Используем генератор
for (int i = 0; i < 10; ++i) {
    gen.move_next();
    // ...
}

// Генератор автоматически уничтожится при выходе из области видимости
// Деструктор вызовет coro.destroy()
```

**Важно:** Бесконечная корутина должна быть явно уничтожена, иначе утечка памяти.

### Несколько независимых генераторов

```cpp
auto gen1 = fibonacci();
auto gen2 = fibonacci();

gen1.move_next();  // gen1: 1
gen2.move_next();  // gen2: 1
gen1.move_next();  // gen1: 1
gen2.move_next();  // gen2: 1
gen1.move_next();  // gen1: 2
gen2.move_next();  // gen2: 1

// Каждый генератор имеет свое независимое состояние
```

**Преимущество:** Можно иметь несколько независимых генераторов с разным состоянием.

### Остановка генерации

```cpp
auto gen = fibonacci();
int count = 0;

while (gen.move_next() && count < 100) {
    int value = gen.current_value();
    if (value > 1000) break;  // Останавливаем при условии
    std::cout << value << std::endl;
    count++;
}
```

**Контроль:** Потребитель полностью контролирует, когда остановить генерацию.

## Связь с предыдущими примерами

- `24_CoSimple` - корутины для конечных последовательностей
- `25_CoFibonacci` - корутины для бесконечных последовательностей
- `05_LambdaGen` - генераторы через лямбды (альтернативный подход)

Это демонстрирует мощь корутин для работы с последовательностями любого размера - от конечных до бесконечных, показывая как они эффективно управляют состоянием и памятью независимо от размера последовательности.

