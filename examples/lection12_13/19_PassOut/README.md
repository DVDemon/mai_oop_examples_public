# Пример: Утечка защищенных данных (Passing Out)

## Описание

Данный пример демонстрирует проблему **"утечки" защищенных данных наружу (passing out)** - ситуацию, когда защищенные мьютексом данные становятся доступны вне защищенной области через указатели или ссылки.

## Суть примера

### Защищенный класс

```cpp
class data_wrapper {
private:
    some_data data;      // Защищенные данные
    std::mutex m;       // Мьютекс для защиты
    
public:
    template<typename Function>
    void process_data(Function func) {
        std::lock_guard<std::mutex> l(m);  // Блокировка
        func(data);  // Передача данных в функцию
    }
};
```

### Проблема: утечка указателя

```cpp
some_data* unprotected;  // Глобальная переменная

void malicious_function(const some_data& protected_data) {
    protected_data.do_something();
    unprotected = (some_data*)&protected_data;  // Утечка указателя!
}

int main() {
    data_wrapper x;
    x.process_data(malicious_function);  // Данные защищены здесь
    
    unprotected->do_something();  // Но доступны здесь без защиты!
}
```

## Проблема

### Что происходит

1. **Внутри `process_data()`** - данные защищены мьютексом
2. **Функция сохраняет указатель** - `malicious_function` сохраняет указатель в глобальную переменную
3. **После выхода из `process_data()`** - мьютекс разблокирован
4. **Доступ через утечку** - данные доступны через `unprotected` **без защиты мьютекса**

### Визуализация проблемы

```
process_data():
    lock() → func(data) → [malicious_function сохраняет указатель] → unlock()
    
После process_data():
    unprotected->do_something()  ← Доступ БЕЗ мьютекса!
```

## Почему это опасно

- **Обход защиты** - данные доступны без синхронизации
- **Race condition** - возможен одновременный доступ из разных потоков
- **Нарушение инвариантов** - данные могут быть изменены некорректно
- **Сложность обнаружения** - проблема не очевидна при чтении кода

## Решения

### 1. Не передавать указатели/ссылки наружу

Функции не должны сохранять указатели или ссылки на защищенные данные:
- Копировать данные, если нужно
- Использовать умные указатели с ограниченным временем жизни
- Избегать глобальных переменных

### 2. Ограничить интерфейс

Не предоставлять прямой доступ к данным:
- Скрыть детали реализации
- Предоставлять только безопасные операции
- Не передавать данные в пользовательские функции

### 3. Документировать ограничения

Если передача данных необходима:
- Четко документировать, что указатели не должны сохраняться
- Использовать контракты или статический анализ
- Проверять код на утечки

## Принцип безопасности

**Защищенные данные должны оставаться защищенными:**
- Мьютекс защищает данные только внутри класса
- Указатели/ссылки на данные не должны "утекать" наружу
- Время жизни защиты должно совпадать с временем жизни доступа

## Связь с предыдущими примерами

- `18_Stack` - потокобезопасный стек (данные не утекают)
- `19_PassOut` - демонстрация проблемы утечки данных
- `20_Future` - альтернативные способы передачи данных между потоками (следующий пример)

Это демонстрирует важность правильного проектирования интерфейсов для потокобезопасных классов.

