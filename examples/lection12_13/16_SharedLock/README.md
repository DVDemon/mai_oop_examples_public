# Пример: Shared Mutex (Множество читателей - один писатель)

## Описание

Данный пример демонстрирует использование **`std::shared_mutex`** и **`std::shared_lock`** для реализации паттерна **"множество читателей - один писатель" (multiple readers, single writer)** - оптимизации, позволяющей нескольким потокам читать данные одновременно.

## Суть примера

### Два типа блокировок

**Для чтения:**
```cpp
void read_data() {
    std::shared_lock<std::shared_mutex> lock(mtx);  // Shared lock
    std::cout << "Reading data: " << shared_data << std::endl;
}
```

**Для записи:**
```cpp
void write_data() {
    std::lock_guard<std::shared_mutex> lock(mtx);  // Exclusive lock
    shared_data++;
    std::cout << "Writing data: " << shared_data << std::endl;
}
```

## Принцип работы

### std::shared_mutex

`std::shared_mutex` поддерживает два типа блокировок:

1. **Shared lock (разделяемая)** - для чтения
   - Множественные потоки могут одновременно получить shared lock
   - Используется через `std::shared_lock`

2. **Exclusive lock (исключительная)** - для записи
   - Только один поток может получить exclusive lock
   - Используется через `std::lock_guard` или `std::unique_lock`

### Правила блокировки

- **Множественные shared locks** - несколько читателей могут работать одновременно
- **Один exclusive lock** - только один писатель может работать
- **Взаимоисключение** - exclusive lock блокирует все (читателей и писателей)
- **Shared lock блокирует** только exclusive lock, но не другие shared locks

## Визуализация

```
Читатель 1: shared_lock() → [читает] → unlock()
Читатель 2: shared_lock() → [читает] → unlock()  ← параллельно!
Читатель 3: shared_lock() → [читает] → unlock()  ← параллельно!

Писатель:   lock_guard() → [пишет] → unlock()  ← блокирует всех
```

## Преимущества

### Производительность

- **Параллельное чтение** - несколько читателей не блокируют друг друга
- **Меньше ожиданий** - читатели не ждут других читателей
- **Оптимизация** - подходит для сценариев с частым чтением и редкой записью

### Типичные сценарии

- **Базы данных** - множество запросов на чтение, редкие обновления
- **Кэши** - частые чтения, редкие обновления
- **Конфигурация** - частое чтение настроек, редкие изменения

## Сравнение с обычным мьютексом

### Обычный mutex (12_Mutex)

```cpp
std::mutex mtx;
std::lock_guard<std::mutex> lock(mtx);  // Блокирует всех
```

**Проблема:** Даже читатели блокируют друг друга

### Shared mutex (16_SharedLock)

```cpp
std::shared_mutex mtx;
std::shared_lock<std::shared_mutex> lock(mtx);  // Не блокирует других читателей
```

**Преимущество:** Читатели работают параллельно

## Когда использовать

**Используйте `shared_mutex` когда:**
- **Частое чтение** - много потоков читают данные
- **Редкая запись** - обновления происходят редко
- **Нужна производительность** - параллельное чтение критично

**Используйте обычный `mutex` когда:**
- Чтение и запись происходят с одинаковой частотой
- Простота важнее производительности
- Нет необходимости в параллельном чтении

## Важные моменты

### Правильное использование

- **Чтение** → `std::shared_lock` (множественные блокировки)
- **Запись** → `std::lock_guard` или `std::unique_lock` (исключительная блокировка)

### Производительность

- `shared_mutex` **медленнее** обычного `mutex` (более сложная реализация)
- Используйте только когда **реальная выгода** от параллельного чтения

### Безопасность

- Писатель **блокирует всех** (читателей и других писателей)
- Читатели **не блокируют** друг друга, но блокируют писателей

## Связь с предыдущими примерами

- `12_Mutex` - обычные мьютексы (взаимоисключение)
- `14_LockGuard` - автоматическое управление мьютексами
- `16_SharedLock` - оптимизация для сценариев "много читателей, мало писателей"

Это демонстрирует оптимизацию синхронизации для конкретных паттернов доступа к данным.

