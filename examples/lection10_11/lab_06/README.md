# Лабораторная работа: Симулятор боев NPC

## Описание

Данная лабораторная работа демонстрирует комплексное применение нескольких паттернов проектирования для создания симулятора боев между различными типами NPC (Non-Player Characters).

## Суть примера

### Компоненты системы

**Типы NPC:**
- `Dragon` - дракон
- `Knight` - рыцарь
- `BlackKnight` - черный рыцарь

Все наследуются от базового класса `NPC` и имеют систему боев друг с другом.

### Применяемые паттерны

#### 1. Factory Method
```cpp
std::shared_ptr<NPC> factory(NpcType type, int x, int y);
std::shared_ptr<NPC> factory(std::istream &is);
```
- Создание NPC через фабрику
- Поддержка создания из потока (сериализация)

#### 2. Observer
```cpp
struct IFightObserver {
    virtual void on_fight(...) = 0;
};

class TextObserver : public IFightObserver;
```
- Уведомления о боях через паттерн Observer
- `TextObserver` выводит информацию о победах

#### 3. Проблема в функции `fight()`

Текущая реализация нарушает принципы проектирования:
```cpp
if (defender->is_dragon())
    success = attacker->fight(std::dynamic_pointer_cast<Dragon>(defender));
if (defender->is_knight())
    success = attacker->fight(std::dynamic_pointer_cast<Knight>(defender));
// ...
```

**Проблемы:**
- Использование `dynamic_cast` - нарушение DIP
- Проверка типов через `is_dragon()`, `is_knight()` - нарушение инкапсуляции
- Множественные условия - сложность расширения

## Задание

Переделать функцию `fight()` на использование паттерна **Visitor**:

```cpp
// Вместо:
if (defender->is_dragon())
    success = attacker->fight(std::dynamic_pointer_cast<Dragon>(defender));

// Должно быть:
success = defender->accept(attacker);
```

## Структура системы

```
┌─────────────────────────────────────────────────────────┐
│                    NPC System                            │
└─────────────────────────────────────────────────────────┘

    ┌──────────────┐
    │     NPC      │
    │              │
    │ +fight()     │◄──────┐
    │ +accept()    │       │
    └──────┬───────┘       │
           │               │
    ┌──────┴───────┐       │
    │              │       │
    ▼              ▼       │
┌─────────┐  ┌─────────┐  │
│ Dragon  │  │ Knight  │  │
│         │  │         │  │
│+fight() │  │+fight() │  │
└─────────┘  └─────────┘  │
                           │
                    ┌──────┴──────┐
                    │   Visitor  │
                    │  (attacker)│
                    └────────────┘
```

## Функциональность

1. **Генерация NPC** - создание 100 случайных NPC разных типов
2. **Сохранение/Загрузка** - сериализация в файл `npc.txt`
3. **Система боев** - NPC сражаются при близком расстоянии
4. **Уведомления** - Observer выводит информацию о победах
5. **Итеративные бои** - бои происходят с увеличивающейся дистанцией

## Цели лабораторной работы

- Применить паттерн Visitor для замены проверок типов
- Понять проблему нарушения DIP при использовании `dynamic_cast`
- Реализовать двойную диспетчеризацию через Visitor
- Убрать методы `is_dragon()`, `is_knight()`, `is_black_knight()`

## Результат

После переделки на Visitor:
- Код станет более расширяемым
- Исчезнет необходимость в проверках типов
- Будет соблюдаться принцип инверсии зависимостей
- Легко добавить новые типы NPC

