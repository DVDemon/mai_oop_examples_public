# Пример: Проблема множественных причин для изменения

## Описание

Данный пример демонстрирует **проблему множественных причин для изменения** класса - изменение одной ответственности требует модификации всего класса.

## Суть примера

В отличие от примера `09_Srp`, где использовался `std::string` для буфера, здесь:

- **Изменен тип данных** - буфер теперь `std::vector<int>` вместо `std::string`
- **Добавлен метод** `NotEmpty()` для проверки наличия данных
- **Изменена логика** `Receive()` - теперь бросает исключение вместо возврата 0

## Проблема

Изменение логики передачи данных (смена типа буфера) потребовало изменений в:
- Методе `Hangup()` - теперь использует `buffer.clear()` вместо `buffer = ""`
- Методе `Send()` - использует `push_back()` вместо `append()`
- Добавлении нового метода `NotEmpty()`

Это демонстрирует, что класс имеет **несколько причин для изменения**:
- Изменения в логике соединения влияют на весь класс
- Изменения в логике передачи данных влияют на весь класс

## Нарушение SRP

Класс `Modem` все еще нарушает принцип единственной ответственности:
- Управление соединением (`Deal`, `Connected`, `Hangup`)
- Передача данных (`Send`, `Receive`, `NotEmpty`)

## Сравнение

Сравните с примерами `11_Srp` и `12_Srp`, где показано правильное разделение ответственностей через интерфейсы.

