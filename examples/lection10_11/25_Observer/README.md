# Пример: Паттерн Observer (Наблюдатель)

## Описание

Данный пример демонстрирует применение паттерна **Observer (Наблюдатель)** - определение зависимости "один ко многим" между объектами, при которой при изменении состояния одного объекта все зависящие от него объекты автоматически уведомляются.

## Суть примера

### Компоненты паттерна

**Observer (Наблюдатель):**
```cpp
class Observer {
    virtual void update(int value) = 0;
};
```

**ConcreteObserver (Конкретные наблюдатели):**
- `ConcreteObserverA`, `ConcreteObserverB` - реагируют на изменения по-разному

**Subject (Субъект):**
```cpp
class Subject {
    virtual void attach(Observer* observer) = 0;  // Подписка
    virtual void detach(Observer* observer) = 0;  // Отписка
    virtual void notify() = 0;                    // Уведомление
};
```

**ConcreteSubject (Конкретный субъект):**
- Хранит список наблюдателей
- При изменении состояния (`setState()`) автоматически уведомляет всех наблюдателей

## Структура паттерна

```
┌─────────────────────────────────────────────────────────┐
│                   Observer Pattern                        │
└─────────────────────────────────────────────────────────┘

    ┌──────────────┐
    │   Subject    │
    │              │
    │ +attach()    │◄───────┐
    │ +detach()    │        │
    │ +notify()    │        │
    └──────┬───────┘        │
           │                │
           │ управляет      │ подписывается
           │                │
           ▼                │
    ┌──────────────┐        │
    │ConcreteSubject│        │
    │              │        │
    │ [observers]  │        │
    │ +setState()  │        │
    └──────────────┘        │
                             │
                             │
    ┌──────────────┐        │
    │   Observer   │◄───────┘
    │              │
    │ +update()    │
    └──────┬───────┘
           │
    ┌──────┴───────┐
    │              │
    ▼              ▼
┌─────────┐  ┌─────────┐
│ObserverA│  │ObserverB│
│         │  │         │
│+update()│  │+update()│
└─────────┘  └─────────┘
```

## Принцип работы

1. **Подписка** - наблюдатели подписываются на субъект через `attach()`
2. **Изменение состояния** - субъект изменяет свое состояние через `setState()`
3. **Автоматическое уведомление** - `setState()` вызывает `notify()`, который уведомляет всех наблюдателей
4. **Реакция наблюдателей** - каждый наблюдатель получает уведомление через `update()` и реагирует соответственно
5. **Отписка** - наблюдатели могут отписаться через `detach()`

## Поток взаимодействия

```
Subject.setState(15)
    │
    ├─► notify()
    │
    ├─► observerA->update(15) ──► "ConcreteObserverA: Reacted..."
    │
    └─► observerB->update(15) ──► "ConcreteObserverB: Reacted..."
```

## Преимущества

- **Слабая связанность** - субъект не знает конкретных типов наблюдателей
- **Динамическая подписка** - наблюдатели могут подписываться/отписываться во время выполнения
- **Расширяемость** - легко добавить новых наблюдателей без изменения субъекта
- **Принцип открытости/закрытости** - субъект открыт для расширения наблюдателями, закрыт для модификации

## Применение

Паттерн Observer полезен когда:
- Изменение одного объекта требует изменения других объектов
- Количество зависимых объектов неизвестно заранее
- Нужна слабая связанность между объектами
- Требуется реализация механизма событий/уведомлений

## Примеры использования

- Системы событий (GUI, игровые движки)
- Модель MVC (Model уведомляет View)
- Подписки на обновления данных
- Реактивное программирование

