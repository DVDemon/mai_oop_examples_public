# Пример: Принцип открытости/закрытости (OCP)

## Описание

Данный пример демонстрирует **принцип открытости/закрытости (Open/Closed Principle, OCP)** - программные сущности должны быть открыты для расширения, но закрыты для модификации.

## Суть примера

Класс `IConnection` работает с абстракцией `IAddress`, а не с конкретными типами адресов:

### Абстракция адреса
```cpp
class IAddress {
    virtual const char* ToString() = 0;
};
```

### Реализации адресов
- `AddressPhone` - телефонный номер
- `AddressIP` - IP-адрес

### Использование абстракции
```cpp
class IConnection {
    std::shared_ptr<IAddress> number;  // Работает с абстракцией
    bool Deal(std::shared_ptr<IAddress> value);
};
```

## Принцип OCP

**Открыт для расширения:**
- Можно добавить новые типы адресов (`AddressEmail`, `AddressURL`, и т.д.)
- Новые классы реализуют интерфейс `IAddress`

**Закрыт для модификации:**
- Класс `IConnection` не нужно изменять при добавлении новых типов адресов
- Существующий код остается неизменным

## Преимущества

- **Расширяемость** - легко добавлять новые типы адресов
- **Стабильность** - существующий код не изменяется
- **Гибкость** - можно использовать любой тип адреса через абстракцию
- **Тестируемость** - можно создавать mock-объекты для тестирования

## Дополнительные возможности

Пример также демонстрирует:
- Использование шаблонов (`Channel<T>`, `IModem<T>`) для работы с разными типами данных
- Использование `std::shared_ptr` для управления памятью

## Сравнение

Сравните с монолитным подходом, где пришлось бы изменять `IConnection` при добавлении каждого нового типа адреса.

