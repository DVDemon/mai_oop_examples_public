# Пример: Паттерн Abstract Factory (Абстрактная фабрика)

## Описание

Данный пример демонстрирует применение паттерна **Abstract Factory (Абстрактная фабрика)** - создание семейств связанных объектов без указания их конкретных классов.

## Суть примера

В отличие от Factory Method, который создает один тип объектов, Abstract Factory создает **семейство связанных объектов**:

### Семейства продуктов
- **Конфигурация**: `IConfig` → `ConsulConfig`, `LocalConfig`
- **Метрики**: `IMetric` → `PrometheusMetric`, `LocalMetric`

### Абстрактная фабрика
```cpp
struct EnvironmentFactory {
    virtual IConfig* CreateConfig() = 0;
    virtual IMetric* CreateMetric() = 0;
};
```

### Конкретные фабрики
- **CloudFactory** - создает `ConsulConfig` и `PrometheusMetric` (для облачного окружения)
- **LocalFactory** - создает `LocalConfig` и `LocalMetric` (для локального окружения)

## Принцип работы

1. **Семейство объектов** - фабрика создает набор связанных объектов, которые должны работать вместе
2. **Гарантия совместимости** - `CloudFactory` создает объекты для облака, `LocalFactory` - для локальной среды
3. **Изоляция создания** - клиент не знает конкретных классов, работает только с абстракциями

## Отличие от Factory Method

- **Factory Method** (`20_FactoryMethod`): создает один тип объектов (например, только `IStorage`)
- **Abstract Factory** (`21_AbstractFactory`): создает семейство связанных объектов (`IConfig` + `IMetric`)

## Преимущества

- **Совместимость** - гарантирует, что созданные объекты работают вместе
- **Изоляция** - клиент не зависит от конкретных классов продуктов
- **Расширяемость** - легко добавить новое семейство (например, `TestFactory`)
- **Соблюдение DIP** - все зависимости направлены к абстракциям

## Применение

Паттерн Abstract Factory полезен когда:
- Необходимо создавать семейства связанных объектов
- Нужна гарантия совместимости объектов из одного семейства
- Требуется изоляция клиента от конкретных классов продуктов

