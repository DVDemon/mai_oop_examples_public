# Пример: Правильное применение принципа подстановки Лисков (LSP)

## Описание

Данный пример демонстрирует **правильное применение принципа подстановки Лисков (LSP)** - классы `Rectangle` и `Square` не связаны наследованием друг с другом, а используют общий интерфейс.

## Суть примера

В отличие от примера `14_Lsp`, где `Square` наследовался от `Rectangle` и нарушал LSP, здесь:

### Общий интерфейс
```cpp
struct Figure {
    virtual int GetSquare() = 0;
};
```

### Независимые классы
- `Rectangle` - имеет методы `SetWidth()` и `SetHeight()`
- `Square` - имеет метод `SetSize()`
- Оба наследуются от `Figure` и реализуют `GetSquare()`

## Решение проблемы LSP

**Не пытаться заменить `Rectangle` на `Square`:**
- Каждый класс имеет свой собственный интерфейс
- Нет попыток подмены поведения методов
- Классы независимы и не нарушают контракты друг друга

**Использовать общий интерфейс:**
- Оба класса реализуют `GetSquare()` из `Figure`
- Можно работать с фигурами через полиморфизм
- Каждый класс сохраняет свою семантику

## Преимущества

- **Соблюдение LSP** - нет попыток подмены поведения
- **Ясная семантика** - каждый класс имеет понятный интерфейс
- **Гибкость** - можно добавлять новые типы фигур через `Figure`
- **Безопасность** - нет неожиданного поведения при подстановке

## Принцип LSP

Объекты должны быть заменяемы только если они **действительно** могут быть использованы вместо друг друга. Если семантика отличается (как у `Rectangle` и `Square`), лучше использовать общий интерфейс, а не наследование.

## Сравнение

Сравните с примером `14_Lsp`, чтобы увидеть разницу между нарушением и соблюдением LSP.

