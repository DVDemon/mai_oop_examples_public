# Пример: Паттерн Visitor (Посетитель)

## Описание

Данный пример демонстрирует применение паттерна **Visitor (Посетитель)** - добавление новых операций над объектами без изменения их классов.

## Структура паттерна (диаграмма)

```
┌─────────────────────────────────────────────────────────────┐
│                        Visitor Pattern                        │
└─────────────────────────────────────────────────────────────┘

    ┌──────────────┐                    ┌──────────────┐
    │   Element    │                    │   Visitor    │
    │              │                    │              │
    │ +accept(v)   │◄───────────────────│ +visit(A&)   │
    └──────┬───────┘                    │ +visit(B&)   │
           │                            └──────┬───────┘
           │                                   │
    ┌──────┴───────┐                    ┌──────┴───────┐
    │              │                    │              │
    ▼              ▼                    ▼              ▼
┌─────────┐  ┌─────────┐        ┌──────────┐  ┌──────────┐
│ElementA │  │ElementB │        │Visitor1  │  │Visitor2  │
│         │  │         │        │          │  │          │
│+accept()│  │+accept()│        │+visit(A) │  │+visit(A) │
│+opA()   │  │+opB()   │        │+visit(B) │  │+visit(B) │
└─────────┘  └─────────┘        └──────────┘  └──────────┘
```

## Поток взаимодействия (двойная диспетчеризация)

```
┌─────────────────────────────────────────────────────────────┐
│                    Двойная диспетчеризация                   │
└─────────────────────────────────────────────────────────────┘

Client: element->accept(visitor)
   │
   │  Шаг 1: Первая диспетчеризация
   │  ┌─────────────────────────────────────┐
   │  │ Выбор метода accept() на основе     │
   │  │ типа элемента (ElementA или ElementB)│
   │  └─────────────────────────────────────┘
   │
   ▼
┌─────────┐                    ┌──────────┐
│ElementA │                    │Visitor1  │
│         │                    │          │
│accept() │───2. visitor.visit(*this)─-──►│
│         │                    │          │
└─────────┘                    │          │
                               │          │
   Шаг 2: Вторая диспетчеризация          │
   ┌───────────────────────────┐         │
   │ Выбор перегрузки visit()  │         │
   │ на основе типа *this      │         │
   │ (ConcreteElementA&)        │         │
   └───────────────────────────┘         │
                               │          │
                               ▼          │
                          ┌──────────┐   │
                          │visit(A&) │   │
                          │  выпол-  │   │
                          │  нение   │   │
                          └──────────┘   │
                                         │
                          ┌──────────────┘
                          │
                          ▼
                    Результат операции
```

### Пример двойной диспетчеризации

```
element->accept(visitor1)
    │
    ├─► [1-я диспетчеризация] Определяется тип element
    │   Если element = ElementA → вызывается ElementA::accept()
    │   Если element = ElementB → вызывается ElementB::accept()
    │
    └─► [2-я диспетчеризация] Внутри accept() вызывается visitor.visit(*this)
        Если visitor = Visitor1 и *this = ElementA& → Visitor1::visit(ElementA&)
        Если visitor = Visitor1 и *this = ElementB& → Visitor1::visit(ElementB&)
        Если visitor = Visitor2 и *this = ElementA& → Visitor2::visit(ElementA&)
        Если visitor = Visitor2 и *this = ElementB& → Visitor2::visit(ElementB&)
```

## Суть примера

### Структура паттерна

**Элементы (Elements):**
- `Element` - абстрактный класс с методом `accept(Visitor&)`
- `ConcreteElementA`, `ConcreteElementB` - конкретные элементы

**Посетители (Visitors):**
- `Visitor` - абстрактный класс с методами `visit()` для каждого типа элемента
- `ConcreteVisitor1`, `ConcreteVisitor2` - конкретные посетители с разной логикой

### Двойная диспетчеризация

```cpp
void ConcreteElementA::accept(Visitor& visitor) {
    visitor.visit(*this);  // Вызывается visit(ConcreteElementA&)
}
```

Метод `accept()` обеспечивает **двойную диспетчеризацию**:
1. Выбор элемента (на основе типа `this`)
2. Выбор посетителя (на основе типа `visitor`)

## Принцип работы

1. **Элемент принимает посетителя** - вызывает `accept(visitor)`
2. **Элемент передает себя посетителю** - `visitor.visit(*this)`
3. **Посетитель обрабатывает элемент** - вызывается правильная перегрузка `visit()`

## Преимущества

- **Расширяемость операций** - можно добавить новый посетитель без изменения элементов
- **Разделение ответственности** - логика операций вынесена в посетителей
- **Группировка операций** - все операции одного типа в одном посетителе
- **Двойная диспетчеризация** - выбор метода на основе типа элемента и посетителя

## Недостатки

- **Сложность добавления элементов** - добавление нового элемента требует изменения всех посетителей
- **Нарушение инкапсуляции** - посетитель должен знать о внутренней структуре элементов

## Применение

Паттерн Visitor полезен когда:
- Нужно выполнить операцию над объектами разных типов
- Операции часто изменяются, а структура элементов стабильна
- Необходимо добавить новые операции без изменения классов элементов
- Операции логически связаны и должны быть сгруппированы

## Связь с другими паттернами

Visitor использует элементы паттерна **Double Dispatch (Двойная диспетчеризация)** для выбора правильного метода на основе типов элемента и посетителя.

