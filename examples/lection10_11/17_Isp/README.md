# Пример: Правильное применение принципа разделения интерфейсов (ISP)

## Описание

Данный пример демонстрирует **правильное применение принципа разделения интерфейсов (ISP)** через использование маленьких специфичных интерфейсов и их композицию с помощью шаблонов.

## Суть примера

В отличие от примера `16_Isp`, где был один большой интерфейс `IBusinessMenu`, здесь:

### Маленькие специфичные интерфейсы
```cpp
class IWine {
    // Только для вина
};

class ICoffe {
    // Только для кофе
};
```

### Композиция через шаблоны
```cpp
template <class... Tail> struct Menu {
    // Комбинирует нужные интерфейсы
};
```

### Гибкое использование
```cpp
Menu<IWine, ICoffe, IWine, ICoffe> menu(...);
// Используются только нужные компоненты
```

## Принцип ISP

**Клиенты не должны зависеть от интерфейсов, которые они не используют.**

Решение:
- **Маленькие интерфейсы** - каждый интерфейс отвечает за одну вещь
- **Композиция вместо наследования** - комбинируем только нужные интерфейсы
- **Шаблоны** - позволяют гибко комбинировать интерфейсы

## Преимущества

- **Нет принуждения** - не нужно реализовывать ненужные методы
- **Гибкость** - можно комбинировать любые интерфейсы
- **Ясность** - каждый интерфейс имеет четкую ответственность
- **Расширяемость** - легко добавить новые типы (`ITea`, `IBeer`, и т.д.)

## Сравнение с `16_Isp`

- `16_Isp`: один большой интерфейс, принуждение к реализации ненужных методов
- `17_Isp`: маленькие интерфейсы, комбинация только нужных компонентов

## Дополнительно

Пример также демонстрирует использование:
- **Variadic templates** - для работы с переменным количеством типов
- **Recursive template instantiation** - для обработки списка типов
- **Static polymorphism** - полиморфизм на этапе компиляции

