# Пример: Оптимизированный Pimpl с размещением в классе

## Описание

Данный пример демонстрирует **оптимизированную версию паттерна Pimpl**, где объект реализации размещается внутри самого класса, а не в куче.

## Суть примера

В отличие от примера `04_Pimpl`, где объект `PaymentMachineImpl` выделялся в куче через `new`, здесь:

- **Хранилище** - используется `std::aligned_storage_t` для размещения объекта внутри класса
- **Placement new** - объект создается в предварительно выделенном хранилище
- **Отсутствие выделения в куче** - объект находится в той же памяти, что и весь класс

## Ключевые отличия от `04_Pimpl`

- `04_Pimpl`: `pimpl = new PaymentMachineImpl{...}` (выделение в куче)
- `05_Pimpl`: `pimpl = new (&this->storage) PaymentMachineImpl{...}` (размещение в классе)

## Преимущества

- **Производительность** - отсутствие выделения памяти в куче
- **Локальность данных** - объект находится рядом с указателем, лучше для кэша процессора
- **Меньше фрагментации** - нет отдельных выделений памяти

## Недостатки

- **Размер класса** - класс становится больше из-за хранилища
- **Сложность управления** - требуется явный вызов деструктора через placement delete

## Сравнение

Сравните с примером `04_Pimpl`, чтобы увидеть разницу в способе размещения объекта реализации.

