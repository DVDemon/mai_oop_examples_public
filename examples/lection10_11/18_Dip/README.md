# Пример: Нарушение принципа инверсии зависимостей (DIP)

## Описание

Данный пример демонстрирует **нарушение принципа инверсии зависимостей (Dependency Inversion Principle, DIP)** - класс `ItemCoffe` зависит от конкретной реализации `ItemBulka`, а не от абстракции.

## Суть примера

### Хорошая часть
Класс `Menu` правильно использует абстракцию:
```cpp
class Menu {
    std::vector<std::shared_ptr<IItem>> items;  // Зависит от абстракции
};
```

### Проблема
Класс `ItemCoffe` нарушает DIP:
```cpp
void print() override {
    // Проверяет конкретный тип через dynamic_cast
    if (std::dynamic_pointer_cast<ItemBulka>(i)) {
        // Зависит от конкретной реализации!
    }
}
```

## Принцип DIP

**Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба должны зависеть от абстракций.**

- **Зависимость от абстракций** - классы должны работать с интерфейсами, а не с конкретными типами
- **Избегать проверок типов** - использование `dynamic_cast` или `typeid` указывает на проблему дизайна
- **Инверсия зависимостей** - зависимости направлены к абстракциям, а не к реализациям

## Проблемы текущей реализации

- **Тесная связанность** - `ItemCoffe` знает о конкретном классе `ItemBulka`
- **Нарушение инкапсуляции** - проверка типов через `dynamic_cast`
- **Слабая расширяемость** - при добавлении нового типа нужно изменять `ItemCoffe`
- **Нарушение OCP** - код не открыт для расширения без модификации

## Решение

Сравните с примером `19_Dip`, где показано правильное применение DIP через использование абстракций вместо проверки конкретных типов.

