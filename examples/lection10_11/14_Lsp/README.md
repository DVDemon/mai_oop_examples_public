# Пример: Нарушение принципа подстановки Лисков (LSP)

## Описание

Данный пример демонстрирует **нарушение принципа подстановки Лисков (Liskov Substitution Principle, LSP)** - производный класс `Square` не может быть использован вместо базового класса `Rectangle` без нарушения ожидаемого поведения.

## Суть примера

Класс `Square` наследуется от `Rectangle`, но нарушает поведенческий контракт:

### Проблема в функции `foo()`
```cpp
void foo(std::shared_ptr<Rectangle> &rec) {
    rec->SetWidth(3);
    rec->SetHeight(4);
    if (rec->GetSquare() != 12) std::cout << "Oops!" << std::endl;
}
```

### Нарушение поведения
- Для `Rectangle`: `SetWidth(3)` и `SetHeight(4)` дают площадь 12 ✓
- Для `Square`: `SetWidth(3)` устанавливает и ширину, и высоту в 3, затем `SetHeight(4)` устанавливает обе в 4, площадь = 16 ✗

## Принцип LSP

**Объекты производного класса должны быть заменяемы объектами базового класса** без изменения корректности программы.

Производный класс должен:
- Сохранять все инварианты базового класса
- Не ослаблять предусловия методов
- Не усиливать постусловия методов

## Проблема

`Square` нарушает LSP, потому что:
- Изменяет семантику методов `SetWidth()` и `SetHeight()`
- Нарушает ожидания клиентского кода, который работает с `Rectangle`
- Не может быть использован везде, где используется `Rectangle`

## Решение

Сравните с примером `15_Lsp`, где показано правильное применение LSP.

