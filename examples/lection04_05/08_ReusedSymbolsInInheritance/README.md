# 08_ReusedSymbolsInInheritance

## Описание
Демонстрирует **переиспользование символов в наследовании** - ситуацию, когда базовый и производный классы имеют поля или методы с одинаковыми именами.

## Классовая диаграмма
```
┌─────────────────┐
│      Parent     │
├─────────────────┤
│ # m_member_var  │ ← protected поле (значение: 100)
│ + print_var()   │
└─────────────────┘
         ▲
         │ public inheritance
         │
┌─────────────────┐
│      Child      │
├─────────────────┤
│ - m_member_var  │ ← private поле (значение: 1000)
│ + print_var()   │ ← переопределенный метод
│ + show_values() │ ← демонстрирует доступ к обоим полям
└─────────────────┘
```

## Ключевые концепции

### 1. Переиспользование символов (Name Hiding)
```cpp
class Parent {
protected:
    int m_member_var{100};  // protected поле
public:
    void print_var() const; // метод для вывода значения
};

class Child : public Parent {
private:
    int m_member_var{1000}; // private поле с ТЕМ ЖЕ ИМЕНЕМ!
public:
    void print_var() const; // переопределенный метод
};
```

### 2. Скрытие полей (Field Hiding)
```cpp
// Поле Child::m_member_var "скрывает" Parent::m_member_var
Child child_object(33);

// Обращение к полю Child (private)
child_object.m_member_var;  // Доступно только внутри класса Child

// Обращение к полю Parent через квалифицированное имя
Parent::m_member_var;  // Доступно в методах Child, т.к. protected в Parent
```

### 3. Скрытие методов (Method Hiding)
```cpp
Child child_object(33);

// Вызов метода Child (переопределенный)
child_object.print_var();  // Вызывает Child::print_var()

// Вызов метода Parent через квалифицированное имя
child_object.Parent::print_var();  // Вызывает Parent::print_var()
```

### 4. Доступ к скрытым полям
```cpp
void Child::show_values() const {
    // Прямое обращение к полю Child
    std::cout << "Child value: " << m_member_var << std::endl;  // 1000
    
    // Обращение к полю Parent через квалифицированное имя
    std::cout << "Parent value: " << Parent::m_member_var << std::endl;  // 100
}
```

### 5. Инициализация в конструкторах
```cpp
Child::Child(int member_var) : m_member_var(member_var) {
    // Инициализируется только Child::m_member_var
    // Parent::m_member_var остается со значением по умолчанию (100)
}
```

## Файлы проекта
- `parent.h` / `parent.cpp` - базовый класс Parent с protected полем
- `child.h` / `child.cpp` - класс Child с полем, скрывающим поле Parent
- `main.cpp` - демонстрация переиспользования символов

## Компиляция и запуск
```bash
g++ -o main main.cpp parent.cpp child.cpp
./main
```

## Ожидаемый вывод
```
=== Method calls ===
The value in child is: 33
The value in parent is: 100

=== Direct field access ===
The value in child is: 33
The value in parent is: 100
```

## Образовательная цель
Понимание механизма скрытия символов в наследовании и способов доступа к скрытым членам базового класса.

## Важные принципы

### 1. Скрытие символов
- Поля/методы производного класса **скрывают** поля/методы базового класса с теми же именами
- Это происходит **независимо** от модификаторов доступа
- Скрытие происходит на уровне **имен**, а не типов

### 2. Доступ к скрытым членам
- Используйте **квалифицированные имена**: `BaseClass::member_name`
- Убедитесь, что скрытый член **доступен** по модификатору доступа
- Protected члены базового класса доступны в производном классе

### 3. Лучшие практики
- **Избегайте** переиспользования имен в наследовании
- Используйте **разные имена** для полей базового и производного классов
- Если необходимо переиспользовать имена, **документируйте** это явно

### 4. Отличие от переопределения
- **Переиспользование символов** - скрытие на уровне имен
- **Переопределение методов** - замена реализации виртуальных методов
- При переиспользовании символов нет полиморфизма

## Практические сценарии
- **Случайное скрытие**: когда разработчик не знает о существовании символа в базовом классе
- **Преднамеренное скрытие**: когда нужно "заблокировать" доступ к члену базового класса
- **Ошибки компиляции**: когда скрытый символ становится недоступен из-за изменения модификатора доступа
