# 02_Iterator - Пользовательский итератор для динамического массива

## Описание

Этот пример демонстрирует создание пользовательского итератора для динамического массива. Показывает, как реализовать итератор, который позволяет использовать стандартные алгоритмы C++ и range-based for loop с пользовательскими контейнерами.

## Ключевые концепции

### 1. Пользовательский итератор (ArrayIterator)
- **Назначение**: Обеспечивает единообразный доступ к элементам контейнера
- **Основные операции**:
  - `operator*()` - разыменование (получение значения)
  - `operator->()` - доступ к членам
  - `operator++()` - инкремент (переход к следующему элементу)
  - `operator!=()` - сравнение итераторов

### 2. Динамический массив (DynamicArray)
- **Умные указатели**: Использует `std::unique_ptr` для автоматического управления памятью
- **Инициализация списком**: Поддержка `std::initializer_list`
- **Безопасность**: Проверка границ с выбросом исключений

### 3. Интеграция со стандартной библиотекой
- **std::begin/std::end**: Автоматическая поддержка стандартных функций
- **Range-based for loop**: Возможность использования современного синтаксиса
- **STL-совместимость**: Работа с алгоритмами стандартной библиотеки

## Структура кода

### Класс OutOfBoundException
```cpp
class OutOfBoundException {
    // Исключение для выхода за границы массива
};
```

### Шаблонный класс ArrayIterator
```cpp
template <class ItemType, class ArrayType>
class ArrayIterator {
    // Пользовательский итератор с базовой функциональностью
};
```

### Шаблонный класс DynamicArray
```cpp
template <class T>
class DynamicArray {
    // Динамический массив с поддержкой итераторов
};
```

## Демонстрационные возможности

### 1. Ручная работа с итераторами
```cpp
auto iterator = array.begin();
++iterator;
std::cout << *iterator << std::endl;
```

### 2. Классический цикл с итераторами
```cpp
for (ArrayIterator<int, DynamicArray<int>> it = array.begin(); 
     it != array.end(); ++it) {
    std::cout << *it << " ";
}
```

### 3. Использование std::begin/std::end
```cpp
for (auto it = std::begin(array); it != std::end(array); ++it) {
    std::cout << *it << " ";
}
```

### 4. Range-based for loop
```cpp
for (auto element : array) {
    std::cout << element << " ";
}
```

### 5. Инициализация списком
```cpp
DynamicArray<int> array{1, 2, 3, 4, 5, 6, 7, 8, 9};
for (auto element : array) {
    std::cout << element << " ";
}
```

## Образовательные цели

1. **Понимание итераторов**: Как работают итераторы в C++
2. **Шаблоны**: Использование шаблонов для создания универсальных классов
3. **Умные указатели**: Безопасное управление памятью с `std::unique_ptr`
4. **Исключения**: Обработка ошибок с помощью исключений
5. **STL-интеграция**: Как сделать пользовательский контейнер совместимым со стандартной библиотекой

## Ключевые улучшения в коде

### Имена переменных
- `array` → `array_pointer`
- `index` → `current_index`
- `size` → `array_size`
- `data` → `data_pointer`
- `it` → `iterator`, `manual_iterator`
- `a` → `element`

### Комментарии
- Подробные Doxygen-комментарии для всех методов
- Объяснение назначения каждого компонента
- Примеры использования в комментариях

### Форматирование
- Единообразные отступы
- Логическая группировка кода
- Четкие разделители между секциями

## Требования

- C++11 или новее (для `std::unique_ptr` и `std::initializer_list`)
- Компилятор с поддержкой шаблонов

## Сборка и запуск

```bash
# Компиляция
g++ -std=c++11 -o iterator main.cpp

# Запуск
./iterator
```

## Ожидаемый вывод

```
=== ДЕМОНСТРАЦИЯ ПОЛЬЗОВАТЕЛЬСКОГО ИТЕРАТОРА ===
1. Работа с итератором вручную:
Значение через итератор: 8
2. Классический цикл с итераторами:
10 8 9 0 0 0 0 0 0 0 
3. Использование std::begin/std::end:
10 8 9 0 0 0 0 0 0 0 
4. Range-based for loop:
10 8 9 0 0 0 0 0 0 0 
5. Инициализация списком и range-based for:
1 2 3 4 5 6 7 8 9 

=== ДЕМОНСТРАЦИЯ ЗАВЕРШЕНА ===
```

## Дополнительные возможности для изучения

1. **Добавление операторов**: `operator==`, `operator<`, `operator+`, `operator-`
2. **Константные итераторы**: Создание `const_iterator`
3. **Обратные итераторы**: Реализация `rbegin()` и `rend()`
4. **Алгоритмы STL**: Использование с `std::sort`, `std::find`, `std::for_each`
