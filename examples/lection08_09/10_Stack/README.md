# 10_Stack - Демонстрация std::stack

## Описание

Этот пример демонстрирует работу с `std::stack` - адаптером контейнера для реализации стека. Показывает принцип LIFO (Last In, First Out), основные операции и ограничения стека.

## Ключевые концепции

### 1. std::stack (Адаптер контейнера)
- **Назначение**: Реализация стека с принципом LIFO
- **Тип**: Адаптер контейнера (не полноценный контейнер)
- **Базовый контейнер**: По умолчанию использует `std::deque`
- **Ограничения**: Нет итераторов, только операции стека

### 2. Принцип LIFO (Last In, First Out)
- **Добавление**: Элементы добавляются только в верх стека
- **Удаление**: Элементы удаляются только с верха стека
- **Доступ**: Доступен только верхний элемент
- **Порядок**: Последний добавленный элемент извлекается первым

### 3. Основные операции
- **push()**: Добавление элемента в верх стека
- **pop()**: Удаление верхнего элемента
- **top()**: Доступ к верхнему элементу
- **empty()**: Проверка на пустоту
- **size()**: Получение количества элементов

### 4. Ограничения std::stack
- **Нет итераторов**: Не поддерживает begin() и end()
- **Нет индексации**: Нельзя получить доступ по индексу
- **Нет range-based for**: Нельзя использовать в циклах for
- **Только стековые операции**: Ограниченный набор операций

## Структура кода

### Демонстрация базовых операций
```cpp
void demonstrateBasicStackOperations() {
    std::stack<int> integer_stack;
    
    // Добавление элементов
    for (int i = 0; i < 10; ++i) {
        integer_stack.push(i);
    }
    
    // Извлечение элементов (LIFO)
    while (!integer_stack.empty()) {
        std::cout << "Размер: " << integer_stack.size() 
                  << ", Верхний: " << integer_stack.top() << std::endl;
        integer_stack.pop();
    }
}
```

### Демонстрация ограничений
```cpp
void demonstrateStackLimitations() {
    // std::stack НЕ ПОДДЕРЖИВАЕТ:
    // - Итераторы
    // - Индексацию
    // - Range-based for loop
    // - Прямой доступ к элементам
}
```

## Демонстрационные возможности

### 1. Добавление элементов
```cpp
std::stack<int> integer_stack;
for (int element_index = 0; element_index < 10; ++element_index) {
    integer_stack.push(element_index);
    std::cout << "Добавлен элемент: " << element_index << std::endl;
}
```

### 2. Извлечение элементов (LIFO)
```cpp
while (!integer_stack.empty()) {
    std::cout << "Размер стека: " << integer_stack.size() 
              << ", Верхний элемент: " << integer_stack.top() << std::endl;
    integer_stack.pop();
}
```

### 3. Проверка состояния стека
```cpp
if (integer_stack.empty()) {
    std::cout << "Стек пуст!" << std::endl;
} else {
    std::cout << "Верхний элемент: " << integer_stack.top() << std::endl;
    std::cout << "Размер стека: " << integer_stack.size() << std::endl;
}
```

## Образовательные цели

1. **Понимание стека**: Принцип LIFO и его применение
2. **Адаптеры контейнеров**: Различия между контейнерами и адаптерами
3. **Ограничения**: Понимание ограничений std::stack
4. **Практическое применение**: Когда использовать стек
5. **Альтернативы**: Когда использовать другие контейнеры

## Ключевые улучшения в коде

### Имена переменных
- `baseTest` → `demonstrateBasicStackOperations` (более описательное)
- `iteratorTest` → `demonstrateStackLimitations` (более описательное)
- `values` → `integer_stack` (более описательное)
- `i` → `element_index` (в циклах)

### Комментарии
- Подробные Doxygen-комментарии для всех функций
- Объяснение назначения каждого теста
- Комментарии к демонстрационным шагам
- Предупреждения об ограничениях

### Форматирование
- Единообразные отступы
- Логическая группировка кода
- Четкие разделители между секциями

## Требования

- C++11 или новее (для `auto` и range-based for)
- Компилятор с поддержкой STL

## Сборка и запуск

```bash
# Компиляция
g++ -std=c++11 -o stack main.cpp

# Запуск
./stack
```

## Ожидаемый вывод

```
=== ДЕМОНСТРАЦИЯ STD::STACK ===

=== ДЕМОНСТРАЦИЯ БАЗОВЫХ ОПЕРАЦИЙ СО СТЕКОМ ===
1. Добавление элементов в стек:
   Добавлен элемент: 0
   Добавлен элемент: 1
   Добавлен элемент: 2
   Добавлен элемент: 3
   Добавлен элемент: 4
   Добавлен элемент: 5
   Добавлен элемент: 6
   Добавлен элемент: 7
   Добавлен элемент: 8
   Добавлен элемент: 9
2. Извлечение элементов из стека (LIFO - Last In, First Out):
   Размер стека: 10, Верхний элемент: 9
   Размер стека: 9, Верхний элемент: 8
   Размер стека: 8, Верхний элемент: 7
   Размер стека: 7, Верхний элемент: 6
   Размер стека: 6, Верхний элемент: 5
   Размер стека: 5, Верхний элемент: 4
   Размер стека: 4, Верхний элемент: 3
   Размер стека: 3, Верхний элемент: 2
   Размер стека: 2, Верхний элемент: 1
   Размер стека: 1, Верхний элемент: 0
   Стек пуст!

=== ОГРАНИЧЕНИЯ STD::STACK ===
1. std::stack НЕ ПОДДЕРЖИВАЕТ ИТЕРАТОРЫ:
   - Нет методов begin() и end()
   - Нет поддержки range-based for loop
   - Нет доступа к элементам по индексу
   - Только операции: push(), pop(), top(), empty(), size()
2. ПРИЧИНЫ ОГРАНИЧЕНИЙ:
   - Стек - это адаптер контейнера, а не полноценный контейнер
   - Принцип LIFO не требует итерации по всем элементам
   - Безопасность: предотвращение случайного доступа к внутренним элементам
3. АЛЬТЕРНАТИВЫ ДЛЯ ИТЕРАЦИИ:
   - Использование базового контейнера (deque, vector, list)
   - Временное копирование элементов в другой контейнер
   - Рекурсивный обход стека

=== ДЕМОНСТРАЦИЯ ЗАВЕРШЕНА ===
```

## Сравнение с другими контейнерами

### std::stack vs std::vector
| Характеристика | std::stack | std::vector |
|----------------|------------|-------------|
| **Тип** | Адаптер контейнера | Полноценный контейнер |
| **Итераторы** | Нет | Есть |
| **Индексация** | Нет | Есть |
| **Доступ к элементам** | Только верхний | Любой |
| **Принцип** | LIFO | Произвольный |

### std::stack vs std::deque
| Характеристика | std::stack | std::deque |
|----------------|------------|------------|
| **Базовый контейнер** | Использует deque | Сам по себе |
| **Операции** | Ограниченные | Полные |
| **Производительность** | Оптимизирован для стека | Универсальный |
| **Гибкость** | Низкая | Высокая |

## Ключевые особенности std::stack

### 1. Адаптер контейнера
- **Не контейнер**: std::stack - это адаптер, а не полноценный контейнер
- **Базовый контейнер**: По умолчанию использует std::deque
- **Ограничения**: Предназначен только для стековых операций
- **Безопасность**: Предотвращает случайный доступ к внутренним элементам

### 2. Принцип LIFO
```cpp
// Добавление элементов
stack.push(1);  // Стек: [1]
stack.push(2);  // Стек: [1, 2]
stack.push(3);  // Стек: [1, 2, 3]

// Извлечение элементов (LIFO)
int top = stack.top();  // top = 3
stack.pop();            // Стек: [1, 2]
```

### 3. Ограничения и причины
- **Нет итераторов**: Принцип LIFO не требует итерации
- **Нет индексации**: Доступ только к верхнему элементу
- **Безопасность**: Предотвращение случайного доступа
- **Производительность**: Оптимизация для стековых операций

## Практические применения

### 1. Обработка выражений
```cpp
std::stack<int> operand_stack;
// Вычисление постфиксных выражений
// "3 4 + 2 *" -> 14
```

### 2. Отмена операций (Undo)
```cpp
std::stack<Action> undo_stack;
// Сохранение состояний для отмены
undo_stack.push(current_action);
```

### 3. Рекурсивные алгоритмы
```cpp
std::stack<int> recursion_stack;
// Замена рекурсии итерацией
while (!recursion_stack.empty()) {
    int current = recursion_stack.top();
    recursion_stack.pop();
    // Обработка current
}
```

### 4. Проверка скобок
```cpp
std::stack<char> bracket_stack;
// Проверка корректности скобок в выражении
for (char c : expression) {
    if (c == '(') bracket_stack.push(c);
    else if (c == ')') bracket_stack.pop();
}
```

## Альтернативы для итерации

### 1. Использование базового контейнера
```cpp
std::deque<int> base_container;
std::stack<int> stack_adapter(base_container);

// Итерация по базовому контейнеру
for (auto it = base_container.begin(); it != base_container.end(); ++it) {
    std::cout << *it << " ";
}
```

### 2. Временное копирование
```cpp
std::stack<int> temp_stack = original_stack;
while (!temp_stack.empty()) {
    std::cout << temp_stack.top() << " ";
    temp_stack.pop();
}
```

### 3. Рекурсивный обход
```cpp
void printStack(std::stack<int>& stack) {
    if (stack.empty()) return;
    
    int top = stack.top();
    stack.pop();
    printStack(stack);  // Рекурсивный вызов
    std::cout << top << " ";
    stack.push(top);
}
```

## Дополнительные возможности для изучения

1. **Кастомные контейнеры**: Создание стека на основе других контейнеров
2. **Производительность**: Сравнение с другими реализациями стека
3. **Многопоточность**: Безопасность стека в многопоточной среде
4. **Специализация**: Создание специализированных версий стека
5. **Алгоритмы**: Использование стека в алгоритмах

Этот пример отлично демонстрирует принцип работы стека и помогает понять, когда использовать std::stack вместо других контейнеров.
