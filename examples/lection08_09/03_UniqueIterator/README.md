# 03_UniqueIterator - Пользовательский список с двумя типами итераторов

## Описание

Этот пример демонстрирует создание пользовательского односвязного списка с двумя различными типами итераторов:
- **Обычные итераторы** (`ListIterator`) - работают через индексы, медленнее, но без инвалидации
- **Быстрые итераторы** (`FastListIterator`) - работают напрямую с указателями, быстрее, но могут инвалидироваться

## Ключевые концепции

### 1. Пользовательский список (List)
- **Структура**: Односвязный список с использованием `std::unique_ptr`
- **Управление памятью**: Автоматическое управление через умные указатели
- **Операции**: `push_back()`, `insert()`, `erase()`, `operator[]`

### 2. Обычные итераторы (ListIterator)
- **Принцип работы**: Используют индексы для доступа к элементам
- **Преимущества**: Стабильность, отсутствие инвалидации при модификациях
- **Недостатки**: Медленный доступ O(n) к элементам
- **Применение**: Когда важна стабильность итераторов

### 3. Быстрые итераторы (FastListIterator)
- **Принцип работы**: Работают напрямую с указателями на узлы списка
- **Преимущества**: Быстрый доступ O(1) к элементам
- **Недостатки**: Могут инвалидироваться при модификациях списка
- **Применение**: Когда важна производительность итерации

### 4. Геометрические объекты (Square)
- **Структура**: Квадрат, заданный четырьмя вершинами
- **Типы**: Шаблонный класс для работы с различными числовыми типами
- **Операции**: Конструкторы, копирование, вывод в поток

## Структура кода

### Класс Square
```cpp
template <class T>
struct Square {
    using vertex_t = std::pair<T,T>;
    vertex_t a, b, c, d;  // Четыре вершины квадрата
    // Конструкторы, операторы копирования
};
```

### Класс List
```cpp
template <class T> 
class List {
    struct ListItem {
        std::unique_ptr<ListItem> next;
        T value;
        // Рекурсивные методы для работы с узлами
    };
    
    class ListIterator { /* Обычные итераторы */ };
    class FastListIterator { /* Быстрые итераторы */ };
};
```

## Демонстрационные возможности

### 1. Создание и инициализация списка
```cpp
List<Square<int>> square_list;
Square<int> small_square(/* координаты */);
square_list.push_back(small_square);
```

### 2. Обычная итерация
```cpp
for (auto square : square_list) {
    std::cout << square << std::endl;
}
```

### 3. Работа с алгоритмами STL
```cpp
// Подсчет квадратов с площадью >= 400
int count = std::count_if(square_list.begin(), square_list.end(),
                         [](const auto& square) -> bool {
                             // Логика проверки площади
                         });
```

### 4. Вставка и удаление элементов
```cpp
auto iterator = square_list.insert(++++square_list.begin(), new_square);
square_list.erase(iterator);
```

### 5. Быстрые итераторы
```cpp
for (auto fast_iterator = square_list.begin_fast(); 
     fast_iterator != square_list.end_fast(); ++fast_iterator) {
    std::cout << *fast_iterator << std::endl;
}
```

## Образовательные цели

1. **Понимание итераторов**: Различия между типами итераторов
2. **Умные указатели**: Использование `std::unique_ptr` для управления памятью
3. **Шаблоны**: Создание универсальных контейнеров
4. **STL-совместимость**: Интеграция с алгоритмами стандартной библиотеки
5. **Производительность**: Компромисс между скоростью и стабильностью

## Ключевые улучшения в коде

### Имена переменных
- `list` → `square_list` (более описательное)
- `s1, s2, s3, s4` → `small_square, medium_square, large_square, extra_large_square`
- `s5` → `new_square`
- `i` → `square` (в циклах)
- `p` → `fast_iterator`
- `val` → `inserted_iterator`

### Комментарии
- Подробные разделители между демонстрациями
- Объяснение назначения каждого типа итератора
- Комментарии к закомментированному коду с объяснением

### Форматирование
- Единообразные отступы
- Логическая группировка кода
- Четкие разделители между секциями

## Требования

- C++11 или новее (для `std::unique_ptr` и `auto`)
- Компилятор с поддержкой шаблонов

## Сборка и запуск

```bash
# Компиляция
g++ -std=c++11 -o unique_iterator main.cpp

# Запуск
./unique_iterator
```

## Ожидаемый вывод

```
=== ДЕМОНСТРАЦИЯ ПОЛЬЗОВАТЕЛЬСКОГО СПИСКА С ИТЕРАТОРАМИ ===
1. Итерация по списку квадратов:
[0,0][10,0][10,10][0,10]
[0,0][20,0][20,20][0,20]
[0,0][30,0][30,30][0,30]
[0,0][40,0][40,40][0,40]
2. Доступ к первому элементу через итератор:
X-координата первой вершины первого квадрата: 0
3. Удаление элемента (4-й элемент):
[0,0][10,0][10,10][0,10]
[0,0][20,0][20,20][0,20]
[0,0][30,0][30,30][0,30]
4. Вставка нового элемента:
[0,0][10,0][10,10][0,10]
[0,0][20,0][20,20][0,20]
[10,10][10,20][20,20][20,10]
[0,0][30,0][30,30][0,30]
5. Удаление вставленного элемента:
[0,0][10,0][10,10][0,10]
[0,0][20,0][20,20][0,20]
[0,0][30,0][30,30][0,30]
6. Использование быстрых итераторов:
[0,0][10,0][10,10][0,10]
[0,0][20,0][20,20][0,20]
[0,0][30,0][30,30][0,30]
7. Сравнение быстрых итераторов:
begin_fast() == begin_fast(): 1
++begin_fast() == begin_fast(): 0

=== ДЕМОНСТРАЦИЯ ЗАВЕРШЕНА ===
```

## Дополнительные возможности для изучения

1. **Константные итераторы**: Создание `const_iterator` и `const_fast_iterator`
2. **Обратные итераторы**: Реализация `rbegin()` и `rend()`
3. **Алгоритмы STL**: Использование с `std::sort`, `std::find`, `std::for_each`
4. **Исключения**: Обработка ошибок при работе с итераторами
5. **Производительность**: Бенчмарки для сравнения скорости итераторов

## Архитектурные особенности

### Обычные итераторы
- **Стабильность**: Не инвалидируются при модификациях
- **Производительность**: O(n) доступ к элементам
- **Безопасность**: Меньше риска segmentation fault

### Быстрые итераторы
- **Производительность**: O(1) доступ к элементам
- **Инвалидация**: Могут стать невалидными при модификациях
- **Риск**: Возможны ошибки при неправильном использовании

Этот пример отлично демонстрирует компромиссы в дизайне итераторов и помогает понять, когда использовать каждый тип.
