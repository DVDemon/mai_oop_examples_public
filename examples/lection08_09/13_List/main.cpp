#include <list>
#include <iostream>

/**
 * Демонстрация размещения элементов std::list в памяти
 * Показывает, что элементы могут быть разбросаны по памяти
 * и анализирует размеры указателей и значений
 */
void testMemoryPlacement() {
    std::cout << "\n=== ТЕСТ РАЗМЕЩЕНИЯ STD::LIST В ПАМЯТИ ===" << std::endl;

    int stack_variable = 0;
    std::list<int> list_data = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    std::cout << "1. Анализ адресов и размеров:" << std::endl;
    std::cout << "   Адрес переменной на стеке: " << &stack_variable << std::endl;
    std::cout << "   Адрес объекта list:        " << &list_data << std::endl;
    
    // ========================================================================
    // АНАЛИЗ РАЗМЕЩЕНИЯ ЭЛЕМЕНТОВ В ПАМЯТИ
    // ========================================================================
    std::cout << "2. Анализ размещения элементов:" << std::endl;
    int* previous_element_pointer = nullptr;
    
    for (auto& current_element : list_data) {
        std::cout << "   Адрес элемента: " << &current_element << std::endl;
        std::cout << "   Размер указателя: " << sizeof(&current_element) << " байт" << std::endl;
        std::cout << "   Размер значения:  " << sizeof(current_element) << " байт" << std::endl;
        
        if (previous_element_pointer) {
            // Вычисление разности адресов между соседними элементами
            long address_difference = &current_element - previous_element_pointer;
            std::cout << "   Разность адресов: " << address_difference << std::endl;
        }
        previous_element_pointer = &current_element;        
    }
}

/**
 * Демонстрация работы с итераторами std::list
 * Показывает двунаправленные итераторы и их инвалидацию при модификации
 */
void testIteratorOperations() {
    std::cout << "\n=== ТЕСТ ОПЕРАЦИЙ С ИТЕРАТОРАМИ STD::LIST ===" << std::endl;

    std::list<int> list_data = {0, 1, 2, 3, 4, 5, 6, 7, 8};

    // ========================================================================
    // ОСНОВНЫЕ ОПЕРАЦИИ С ДВУНАПРАВЛЕННЫМИ ИТЕРАТОРАМИ
    // ========================================================================
    std::cout << "1. Базовые операции с двунаправленными итераторами:" << std::endl;
    auto current_iterator = std::next(list_data.cbegin(), 3);
    std::cout << "   Элемент на позиции 3: " << *current_iterator << std::endl;

    // Перемещение вперед
    ++current_iterator;
    std::cout << "   Следующий элемент: " << *current_iterator << std::endl;

    // Перемещение назад (двунаправленные итераторы)
    --current_iterator;
    --current_iterator;
    std::cout << "   Предыдущий элемент: " << *current_iterator << std::endl;

    // ========================================================================
    // ОГРАНИЧЕНИЯ ДВУНАПРАВЛЕННЫХ ИТЕРАТОРОВ
    // ========================================================================
    std::cout << "2. Ограничения двунаправленных итераторов:" << std::endl;
    std::cout << "   - НЕТ оператора += (прямое перемещение)" << std::endl;
    std::cout << "   - ЕСТЬ операторы ++ и -- (пошаговое перемещение)" << std::endl;
    
    // Закомментированная операция, которая НЕ РАБОТАЕТ:
    // current_iterator += 3;  // ОШИБКА КОМПИЛЯЦИИ!
    
    // Альтернатива для перемещения на несколько позиций
    std::advance(current_iterator, 3);
    std::cout << "   Элемент через 3 позиции (std::advance): " << *current_iterator << std::endl;

    // ========================================================================
    // РАБОТА С ПОЗИЦИЯМИ ИТЕРАТОРОВ
    // ========================================================================
    auto iterator_position = std::distance(list_data.cbegin(), current_iterator);
    std::cout << "   Позиция итератора: " << iterator_position << std::endl;

    // ========================================================================
    // ОПЕРАЦИИ ВСТАВКИ И ИХ ВЛИЯНИЕ НА ИТЕРАТОРЫ
    // ========================================================================
    std::cout << "3. Операции вставки и влияние на итераторы:" << std::endl;
    
    // Добавление элементов в конец и начало
    list_data.push_back(42);
    list_data.push_front(42);
    std::cout << "   Добавлены элементы в конец и начало списка" << std::endl;

    std::cout << "   Адрес первого элемента: " << &*list_data.cbegin() << std::endl;
    std::cout << "   Адрес элемента на позиции " << iterator_position << ": " 
              << &*(std::next(list_data.cbegin(), iterator_position)) << std::endl;
    
    // ========================================================================
    // ВАЖНО: ИТЕРАТОРЫ МОГУТ СТАТЬ НЕВАЛИДНЫМИ ПРИ МОДИФИКАЦИИ
    // ========================================================================
    std::cout << "   Адрес элемента через итератор: " << &*current_iterator << std::endl;
    std::cout << "   ВНИМАНИЕ: Итератор может стать невалидным после модификации!" << std::endl;
    // std::cout << *current_iterator << std::endl;  // ОПАСНО!

    // ========================================================================
    // ВСТАВКА В НАЧАЛО СПИСКА
    // ========================================================================
    auto new_iterator = std::next(list_data.cbegin(), 3);
    std::cout << "   Элемент на позиции 3: " << *new_iterator << std::endl;
    
    std::cout << "   Вставка элемента в начало списка..." << std::endl;
    list_data.insert(list_data.cbegin(), 42);
    std::cout << "   Элемент на позиции 3 после вставки: " << *new_iterator << std::endl;
}

/**
 * Основная функция - демонстрация std::list
 * Показывает особенности двусвязного списка и двунаправленных итераторов
 */
int main() {
    std::cout << "=== ДЕМОНСТРАЦИЯ STD::LIST ===" << std::endl;

    // Тест 1: Размещение элементов в памяти
    testMemoryPlacement();
    
    // Тест 2: Операции с итераторами
    testIteratorOperations();

    std::cout << "\n=== ДЕМОНСТРАЦИЯ ЗАВЕРШЕНА ===" << std::endl;
    return 0;
}