#include <iostream>

int main() {
    
    // ==========================================
    // 1. ОБЫЧНОЕ ИСПОЛЬЗОВАНИЕ УКАЗАТЕЛЕЙ (СТЕК)
    // ==========================================
    
    std::cout << "=== Обычное использование указателей (стек) ===" << std::endl;
    
    int stack_variable{22};  // Переменная в стеке
    int* pointer_to_stack{&stack_variable};  // Указатель на переменную в стеке
    
    std::cout << "Значение переменной в стеке: " << stack_variable << std::endl;
    std::cout << "Адрес переменной в стеке: " << &stack_variable << std::endl;
    std::cout << "Адрес в указателе: " << pointer_to_stack << std::endl;
    std::cout << "Значение через указатель: " << *pointer_to_stack << std::endl;
    std::cout << std::endl;
    
    // ==========================================
    // 2. НЕИНИЦИАЛИЗИРОВАННЫЕ УКАЗАТЕЛИ
    // ==========================================
    
    std::cout << "=== Неинициализированные указатели ===" << std::endl;
    
    int* uninitialized_pointer;  // Содержит случайный адрес (мусор)
    int valid_variable{12};
    uninitialized_pointer = &valid_variable;  // Направляем на валидный адрес
    
    std::cout << "После инициализации указателя:" << std::endl;
    std::cout << "Значение через указатель: " << *uninitialized_pointer << std::endl;
    std::cout << std::endl;
    
    // ==========================================
    // 3. ОПАСНОСТЬ РАБОТЫ С НЕИНИЦИАЛИЗИРОВАННЫМИ УКАЗАТЕЛЯМИ
    // ==========================================
    
    std::cout << "=== ОПАСНОСТЬ: Работа с неинициализированными указателями ===" << std::endl;
    std::cout << "Следующий код ЗАКОММЕНТИРОВАН, так как он ОПАСЕН и может вызвать КРАШ:" << std::endl;
    
    // ОПАСНЫЙ КОД - ЗАКОММЕНТИРОВАН ДЛЯ БЕЗОПАСНОСТИ:
    /*
    int* dangerous_pointer;  // Содержит случайный адрес
    std::cout << "Попытка записи в случайный адрес..." << std::endl;
    *dangerous_pointer = 55;  // ЗАПИСЬ В СЛУЧАЙНЫЙ АДРЕС - ОПАСНО!
    std::cout << "Адрес в указателе: " << dangerous_pointer << std::endl;
    std::cout << "Значение по случайному адресу: " << *dangerous_pointer << std::endl;
    //*/
    
    std::cout << "Этот код может вызвать краш программы или повреждение данных!" << std::endl;
    std::cout << std::endl;
    
    // ==========================================
    // 4. УКАЗАТЕЛИ НА nullptr
    // ==========================================
    
    std::cout << "=== Указатели на nullptr ===" << std::endl;
    
    int* null_pointer{};  // Инициализирован nullptr (эквивалент нуля для указателей)
    // int* null_pointer{nullptr};  // Альтернативный способ инициализации
    
    std::cout << "Указатель инициализирован nullptr (указывает в никуда)" << std::endl;
    
    // ОПАСНЫЙ КОД - ЗАКОММЕНТИРОВАН ДЛЯ БЕЗОПАСНОСТИ:
    std::cout << "Следующий код ЗАКОММЕНТИРОВАН, так как он ОПАСЕН:" << std::endl;
    // *null_pointer = 33;  // ЗАПИСЬ В nullptr - КРАШ!
    // std::cout << "Значение через nullptr: " << *null_pointer << std::endl;  // ЧТЕНИЕ ИЗ nullptr - КРАШ!
    
    std::cout << "Работа с nullptr может вызвать краш программы!" << std::endl;
    std::cout << std::endl;
    
    // ==========================================
    // 5. ДИНАМИЧЕСКОЕ ВЫДЕЛЕНИЕ ПАМЯТИ (КУЧА)
    // ==========================================
    
    std::cout << "=== Динамическое выделение памяти (куча) ===" << std::endl;
    
    int* heap_pointer{nullptr};
    heap_pointer = new int;  // Динамически выделяем память для одного int в куче
    
    // Эта память теперь принадлежит нашей программе
    // Система не может использовать её для других целей, пока мы её не освободим
    // После выполнения этой строки у нас будет валидный адрес памяти
    // Размер выделенной памяти достаточен для хранения типа, на который указывает указатель
    
    *heap_pointer = 77;  // Записываем значение в динамически выделенную память
    
    std::cout << "Динамически выделенная память:" << std::endl;
    std::cout << "Адрес в куче: " << heap_pointer << std::endl;
    std::cout << "Значение в куче: " << *heap_pointer << std::endl;
    
    // ВАЖНО: Освобождаем память обратно в систему
    delete heap_pointer;
    heap_pointer = nullptr;  // Устанавливаем указатель в nullptr для безопасности
    std::cout << "Память освобождена, указатель установлен в nullptr" << std::endl;
    std::cout << std::endl;
    
    // ==========================================
    // 6. ИНИЦИАЛИЗАЦИЯ ПРИ ОБЪЯВЛЕНИИ
    // ==========================================
    
    std::cout << "=== Инициализация указателей при объявлении ===" << std::endl;
    
    // Можно инициализировать указатель валидным адресом при объявлении
    int* uninitialized_heap_pointer{new int};           // Память содержит случайное значение
    int* initialized_heap_pointer1{new int(22)};         // Прямая инициализация
    int* initialized_heap_pointer2{new int{23}};        // Унифицированная инициализация
    
    std::cout << "Указатели с динамически выделенной памятью:" << std::endl;
    std::cout << "Неинициализированная память: " << *uninitialized_heap_pointer << " (случайное значение)" << std::endl;
    std::cout << "Прямая инициализация: " << *initialized_heap_pointer1 << std::endl;
    std::cout << "Унифицированная инициализация: " << *initialized_heap_pointer2 << std::endl;
    std::cout << std::endl;
    
    // ВАЖНО: Не забываем освободить всю выделенную память
    std::cout << "Освобождение всей выделенной памяти:" << std::endl;
    delete uninitialized_heap_pointer;
    uninitialized_heap_pointer = nullptr;
    
    delete initialized_heap_pointer1;
    initialized_heap_pointer1 = nullptr;
    
    delete initialized_heap_pointer2;
    initialized_heap_pointer2 = nullptr;
    std::cout << "Вся память освобождена" << std::endl;
    std::cout << std::endl;
    
    // ==========================================
    // 7. ПОВТОРНОЕ ИСПОЛЬЗОВАНИЕ УКАЗАТЕЛЕЙ
    // ==========================================
    
    std::cout << "=== Повторное использование указателей ===" << std::endl;
    
    // Можно повторно использовать указатель после освобождения памяти
    uninitialized_heap_pointer = new int(81);
    std::cout << "Новое значение в переиспользованном указателе: " << *uninitialized_heap_pointer << std::endl;
    
    delete uninitialized_heap_pointer;
    uninitialized_heap_pointer = nullptr;
    std::cout << "Память освобождена повторно" << std::endl;
    std::cout << std::endl;
    
    // ==========================================
    // 8. ОПАСНОСТЬ ДВОЙНОГО ОСВОБОЖДЕНИЯ ПАМЯТИ
    // ==========================================
    
    std::cout << "=== ОПАСНОСТЬ: Двойное освобождение памяти ===" << std::endl;
    
    uninitialized_heap_pointer = new int(99);
    std::cout << "Новое значение: " << *uninitialized_heap_pointer << std::endl;
    
    // Первое освобождение - корректно
    delete uninitialized_heap_pointer;
    std::cout << "Первое освобождение памяти выполнено" << std::endl;
    
    // ОПАСНОСТЬ: Второе освобождение - ОПАСНО!
    std::cout << "Следующий код ЗАКОММЕНТИРОВАН, так как он ОПАСЕН:" << std::endl;
    //uninitialized_heap_pointer = nullptr;  // Без этого строка ниже вызовет краш
    //delete uninitialized_heap_pointer;     // ДВОЙНОЕ ОСВОБОЖДЕНИЕ - КРАШ!
    
    std::cout << "Двойное освобождение памяти может вызвать краш программы!" << std::endl;
    std::cout << "ВСЕГДА устанавливайте указатель в nullptr после delete!" << std::endl;
    std::cout << std::endl;
    
    // ==========================================
    // 9. ПРАВИЛА УПРАВЛЕНИЯ ПАМЯТЬЮ
    // ==========================================
    
    std::cout << "=== Правила управления памятью ===" << std::endl;
    std::cout << "1. ВСЕГДА освобождайте память с помощью delete" << std::endl;
    std::cout << "2. ВСЕГДА устанавливайте указатель в nullptr после delete" << std::endl;
    std::cout << "3. НИКОГДА не освобождайте память дважды" << std::endl;
    std::cout << "4. НИКОГДА не работайте с неинициализированными указателями" << std::endl;
    std::cout << "5. НИКОГДА не разыменовывайте nullptr" << std::endl;
    std::cout << std::endl;
    
    std::cout << "Программа завершается корректно" << std::endl;
    return 0;
}