#include <iostream>

int main() {
    
    // ==========================================
    // 1. СОЗДАНИЕ МАССИВА И УКАЗАТЕЛЯ
    // ==========================================
    
    // Создаем массив из 10 элементов
    int student_scores[10]{11, 12, 13, 14, 15, 16, 17, 18, 19, 20};
    
    // Создаем указатель на массив
    int* navigation_pointer{student_scores};
    
    // Попытка инкрементировать имя массива вызовет ошибку компиляции:
    // student_scores++;  // ОШИБКА: нельзя изменять имя массива
    
    // ==========================================
    // 2. РУЧНОЕ УВЕЛИЧЕНИЕ АДРЕСА УКАЗАТЕЛЯ
    // ==========================================
    
    std::cout << "=== Ручное увеличение адреса указателя ===" << std::endl;
    std::cout << "Каждый инкремент перемещает указатель на sizeof(int) = " << sizeof(int) << " байт" << std::endl;
    std::cout << std::endl;
    
    // Демонстрируем ручное перемещение указателя по массиву
    for (int i = 0; i < 10; ++i) {
        std::cout << "Адрес: " << navigation_pointer << " | Значение: " << *navigation_pointer << std::endl;
        if (i < 9) {  // Не инкрементируем после последнего элемента
            ++navigation_pointer;  // Перемещаемся на sizeof(int) байт вперед
        }
    }
    std::cout << std::endl;
    
    // ==========================================
    // 3. ЯВНОЕ СЛОЖЕНИЕ С ЦЕЛЫМ ЧИСЛОМ
    // ==========================================
    
    std::cout << "=== Явное сложение указателя с целым числом ===" << std::endl;
    navigation_pointer = student_scores;  // Сбрасываем указатель на начало массива
    
    // Перемещаемся на 4 элемента вперед
    std::cout << "Элемент с индексом 4: " << *(navigation_pointer + 4) << std::endl;
    std::cout << "Адрес элемента с индексом 4: " << (navigation_pointer + 4) << std::endl;
    std::cout << "Разность адресов: " << (navigation_pointer + 4) - navigation_pointer << " элементов" << std::endl;
    std::cout << std::endl;
    
    // ==========================================
    // 4. АРИФМЕТИКА УКАЗАТЕЛЕЙ В ЦИКЛЕ
    // ==========================================
    
    std::cout << "=== Арифметика указателей в цикле ===" << std::endl;
    navigation_pointer = student_scores;
    
    std::cout << "Элементы массива через арифметику указателей:" << std::endl;
    for (size_t i{0}; i < std::size(student_scores); ++i) {
        std::cout << "Элемент " << i << ": " << *(navigation_pointer + i) << std::endl;
    }
    std::cout << std::endl;
    
    // ==========================================
    // 5. АРИФМЕТИКА НА ИМЕНИ МАССИВА
    // ==========================================
    
    std::cout << "=== Арифметика на имени массива ===" << std::endl;
    std::cout << "Имя массива ведет себя как указатель на первый элемент:" << std::endl;
    
    for (size_t i{0}; i < std::size(student_scores); ++i) {
        std::cout << "Элемент " << i << ": " << *(student_scores + i) << std::endl;
    }
    std::cout << std::endl;
    
    // ==========================================
    // 6. ОБРАТНЫЙ ПОРЯДОК ЧЕРЕЗ АРИФМЕТИКУ УКАЗАТЕЛЕЙ
    // ==========================================
    
    std::cout << "=== Обратный порядок через арифметику указателей ===" << std::endl;
    std::cout << "Элементы в обратном порядке:" << std::endl;
    
    for (size_t i{std::size(student_scores)}; i > 0; --i) {
        // Используем (i - 1) потому что массив начинается с индекса 0
        std::cout << "Элемент " << (i - 1) << ": " << *(student_scores + i - 1) << std::endl;
    }
    std::cout << std::endl;
    
    // ==========================================
    // 7. ОБРАТНЫЙ ПОРЯДОК ЧЕРЕЗ ДЕКРЕМЕНТ УКАЗАТЕЛЯ
    // ==========================================
    
    std::cout << "=== Обратный порядок через декремент указателя ===" << std::endl;
    
    // Устанавливаем указатель на последний элемент массива
    navigation_pointer = student_scores + std::size(student_scores) - 1;
    
    std::cout << "Элементы в обратном порядке через декремент:" << std::endl;
    for (size_t i{std::size(student_scores)}; i > 0; --i) {
        std::cout << "Значение: " << *(navigation_pointer--) << std::endl;
    }
    std::cout << std::endl;
    
    // ==========================================
    // 8. ОБРАТНЫЙ ПОРЯДОК ЧЕРЕЗ ИНДЕКСАЦИЮ МАССИВА
    // ==========================================
    
    std::cout << "=== Обратный порядок через индексацию массива ===" << std::endl;
    std::cout << "Элементы в обратном порядке через индексацию:" << std::endl;
    
    for (size_t i{std::size(student_scores)}; i > 0; --i) {
        std::cout << "Элемент " << (i - 1) << ": " << student_scores[i - 1] << std::endl;
    }
    std::cout << std::endl;
    
    // ==========================================
    // 9. ИЗМЕНЕНИЕ ЭЛЕМЕНТОВ МАССИВА РАЗЛИЧНЫМИ СПОСОБАМИ
    // ==========================================
    
    std::cout << "=== Изменение элементов массива различными способами ===" << std::endl;
    
    // Сбрасываем указатель на начало массива
    navigation_pointer = student_scores;
    
    // Изменяем элементы тремя различными способами:
    student_scores[0] = 31;           // Способ 1: Индексация массива
    *(student_scores + 1) = 32;       // Способ 2: Арифметика на имени массива
    *(navigation_pointer + 2) = 33;   // Способ 3: Арифметика на указателе
    
    std::cout << "Массив после изменения первых трех элементов:" << std::endl;
    for (size_t i{0}; i < std::size(student_scores); ++i) {
        std::cout << "Элемент " << i << ": " << student_scores[i] << std::endl;
    }
    std::cout << std::endl;
    
    // ==========================================
    // 10. ДОПОЛНИТЕЛЬНЫЕ ПРИМЕРЫ АРИФМЕТИКИ УКАЗАТЕЛЕЙ
    // ==========================================
    
    std::cout << "=== Дополнительные примеры арифметики указателей ===" << std::endl;
    
    navigation_pointer = student_scores;
    
    // Разность указателей
    int* start_pointer = student_scores;
    int* end_pointer = student_scores + 5;
    std::cout << "Разность указателей (элементов между ними): " << (end_pointer - start_pointer) << std::endl;
    
    // Сравнение указателей
    std::cout << "start_pointer < end_pointer: " << (start_pointer < end_pointer) << std::endl;
    std::cout << "start_pointer == end_pointer: " << (start_pointer == end_pointer) << std::endl;
    
    return 0;
}