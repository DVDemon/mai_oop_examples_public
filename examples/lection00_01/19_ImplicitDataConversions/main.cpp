/*
 * НЕЯВНЫЕ ПРЕОБРАЗОВАНИЯ ТИПОВ ДАННЫХ В C++
 * 
 * Этот файл демонстрирует неявные (автоматические) преобразования типов:
 * - Преобразования в арифметических выражениях
 * - Преобразования при присваивании
 * - Расширяющие и сужающие преобразования
 * - Потеря точности при преобразованиях
 * - Практические примеры и рекомендации
 */

#include <iostream>  // Для потоков ввода-вывода

int main() {
    /*
     * НЕЯВНЫЕ ПРЕОБРАЗОВАНИЯ В АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЯХ
     * 
     * Компилятор автоматически применяет неявные преобразования,
     * когда типы данных в выражении различаются.
     * 
     * Правило: преобразование всегда происходит от меньшего типа к большему
     * (расширяющее преобразование), чтобы сохранить точность.
     */
    double item_price {45.67};  // Цена товара (вещественное число)
    int item_quantity {10};     // Количество товара (целое число)
    
    /*
     * АВТОМАТИЧЕСКОЕ ПРЕОБРАЗОВАНИЕ В ВЫРАЖЕНИИ
     * 
     * При умножении price * units:
     * 1. int units автоматически преобразуется в double
     * 2. Выполняется умножение double * double
     * 3. Результат имеет тип double
     * 
     * Это расширяющее преобразование (int → double) безопасно
     */
    auto total_cost = item_price * item_quantity;  // units преобразуется в double
    
    std::cout << "=== НЕЯВНЫЕ ПРЕОБРАЗОВАНИЯ В ВЫРАЖЕНИЯХ ===" << std::endl;
    std::cout << "Цена товара: " << item_price << " рублей" << std::endl;
    std::cout << "Количество: " << item_quantity << " штук" << std::endl;
    std::cout << "Общая стоимость: " << total_cost << " рублей" << std::endl;
    std::cout << "Размер total_cost: " << sizeof(total_cost) << " байт (double)" << std::endl;
    std::cout << std::endl;

    /*
     * НЕЯВНЫЕ ПРЕОБРАЗОВАНИЯ ПРИ ПРИСВАИВАНИИ
     * 
     * При присваивании значения одного типа переменной другого типа
     * происходит неявное преобразование.
     * 
     * ВНИМАНИЕ: сужающие преобразования могут привести к потере данных!
     */
    std::cout << "=== НЕЯВНЫЕ ПРЕОБРАЗОВАНИЯ ПРИ ПРИСВАИВАНИИ ===" << std::endl;
    
    int integer_result;                    // Переменная типа int
    double precise_value {45.44};          // Вещественное значение
    
    /*
     * СУЖАЮЩЕЕ ПРЕОБРАЗОВАНИЕ (double → int)
     * 
     * При присваивании double значения переменной int:
     * 1. Дробная часть отбрасывается (не округляется!)
     * 2. Происходит потеря точности
     * 3. 45.44 становится 45
     */
    integer_result = precise_value;        // double преобразуется в int
    
    std::cout << "Исходное значение (double): " << precise_value << std::endl;
    std::cout << "После преобразования (int): " << integer_result << std::endl;
    std::cout << "Размер integer_result: " << sizeof(integer_result) << " байт (int)" << std::endl;
    std::cout << "ПОТЕРЯ ТОЧНОСТИ: дробная часть .44 отброшена!" << std::endl;
    std::cout << std::endl;

    /*
     * ДОПОЛНИТЕЛЬНЫЕ ПРИМЕРЫ НЕЯВНЫХ ПРЕОБРАЗОВАНИЙ
     * 
     * Демонстрация различных типов неявных преобразований
     * и их последствий
     */
    std::cout << "=== ДОПОЛНИТЕЛЬНЫЕ ПРИМЕРЫ ПРЕОБРАЗОВАНИЙ ===" << std::endl;
    
    // Пример 1: char → int
    const char letter = 'A';
    int ascii_code = letter;  // char автоматически преобразуется в int
    std::cout << "Символ '" << letter << "' имеет ASCII код: " << ascii_code << std::endl;
    
    // Пример 2: int → double (расширяющее преобразование)
    int whole_number = 100;
    double real_number = whole_number;  // int преобразуется в double
    std::cout << "Целое число " << whole_number << " преобразовано в " << real_number << std::endl;
    
    // Пример 3: float → double
    float single_precision = 3.14159f;
    double double_precision = single_precision;  // float преобразуется в double
    std::cout << "float " << single_precision << " преобразован в double " << double_precision << std::endl;
    
    // Пример 4: bool → int
    bool is_true = true;
    bool is_false = false;
    int true_as_int = is_true;   // true становится 1
    int false_as_int = is_false; // false становится 0
    std::cout << "true преобразовано в int: " << true_as_int << std::endl;
    std::cout << "false преобразовано в int: " << false_as_int << std::endl;
    std::cout << std::endl;

    /*
     * ПРОБЛЕМЫ С НЕЯВНЫМИ ПРЕОБРАЗОВАНИЯМИ
     * 
     * Демонстрация потенциальных проблем и потери данных
     */
    std::cout << "=== ПРОБЛЕМЫ С НЕЯВНЫМИ ПРЕОБРАЗОВАНИЯМИ ===" << std::endl;
    
    // Проблема 1: Потеря точности при преобразовании double → int
    double large_decimal = 123.999;
    int truncated_int = large_decimal;  // 123.999 становится 123
    std::cout << "double " << large_decimal << " → int " << truncated_int << " (потеря .999)" << std::endl;
    
    // Проблема 2: Переполнение при преобразовании
    int large_int = 300;
    char small_char = large_int;  // 300 не помещается в char (-128 до 127)
    std::cout << "int " << large_int << " → char " << (int)small_char << " (переполнение!)" << std::endl;
    
    // Проблема 3: Отрицательные числа в unsigned типах
    int negative_number = -5;
    unsigned int unsigned_result = negative_number;  // -5 становится очень большим числом
    std::cout << "int " << negative_number << " → unsigned int " << unsigned_result << " (неожиданный результат!)" << std::endl;
    std::cout << std::endl;

    /*
     * РЕКОМЕНДАЦИИ ПО ИСПОЛЬЗОВАНИЮ НЕЯВНЫХ ПРЕОБРАЗОВАНИЙ
     * 
     * Практические советы для безопасного использования
     */
    std::cout << "=== РЕКОМЕНДАЦИИ ===" << std::endl;
    std::cout << "1. Будьте осторожны с сужающими преобразованиями" << std::endl;
    std::cout << "2. Используйте явные преобразования (static_cast) для ясности" << std::endl;
    std::cout << "3. Проверяйте диапазоны значений перед преобразованием" << std::endl;
    std::cout << "4. Предпочитайте расширяющие преобразования сужающим" << std::endl;
    std::cout << "5. Используйте компилятор с предупреждениями о преобразованиях" << std::endl;
    std::cout << std::endl;
   
    return 0;
}

/*
 * РЕЗЮМЕ: НЕЯВНЫЕ ПРЕОБРАЗОВАНИЯ ТИПОВ В C++
 * 
 * 1. ОСНОВНЫЕ ПОНЯТИЯ:
 *    - Неявные преобразования происходят автоматически
 *    - Компилятор применяет их при несовпадении типов
 *    - Преобразования могут быть расширяющими или сужающими
 * 
 * 2. ПРАВИЛА ПРЕОБРАЗОВАНИЙ:
 *    - В выражениях: от меньшего типа к большему
 *    - При присваивании: к типу целевой переменной
 *    - Расширяющие преобразования безопасны
 *    - Сужающие преобразования могут привести к потере данных
 * 
 * 3. ТИПЫ ПРЕОБРАЗОВАНИЙ:
 *    - Целые типы: char → int → long → long long
 *    - Вещественные: float → double → long double
 *    - Смешанные: int → double, char → int
 *    - Логические: bool → int (true=1, false=0)
 * 
 * 4. ПРОБЛЕМЫ И РИСКИ:
 *    - Потеря точности (дробная часть отбрасывается)
 *    - Переполнение (значение не помещается в целевой тип)
 *    - Неожиданные результаты с unsigned типами
 *    - Скрытые ошибки в коде
 * 
 * 5. ПРАКТИЧЕСКИЕ ПРИМЕНЕНИЯ:
 *    - Арифметические операции с разными типами
 *    - Присваивание значений разных типов
 *    - Передача параметров в функции
 *    - Возврат значений из функций
 * 
 * 6. РЕКОМЕНДАЦИИ:
 *    - Используйте явные преобразования (static_cast) для ясности
 *    - Включайте предупреждения компилятора о преобразованиях
 *    - Проверяйте диапазоны значений перед преобразованием
 *    - Предпочитайте расширяющие преобразования
 *    - Документируйте намеренные преобразования
 * 
 * 7. ВАЖНЫЕ ЗАМЕЧАНИЯ:
 *    - Неявные преобразования могут скрывать ошибки
 *    - Всегда проверяйте результаты преобразований
 *    - Используйте современные стандарты C++ для лучшей безопасности
 *    - Изучайте предупреждения компилятора
 * 
 * 8. ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ:
 *    - explicit конструкторы (предотвращение неявных преобразований)
 *    - Пользовательские операторы преобразования
 *    - SFINAE для условных преобразований
 *    - Concepts (C++20) для ограничения типов
 */