/*
 * МНОЖЕСТВЕННЫЕ ОБЪЯВЛЕНИЯ В ЦИКЛЕ FOR В C++
 * 
 * Этот файл демонстрирует использование множественных объявлений
 * и операций в цикле for:
 * - Объявление нескольких переменных в инициализации
 * - Множественные операции в обновлении
 * - Сложные условия в цикле
 * - Практические примеры и рекомендации
 */

#include <iostream>  // Для потоков ввода-вывода

int main() {
    /*
     * МНОЖЕСТВЕННЫЕ ОБЪЯВЛЕНИЯ И ОПЕРАЦИИ В ЦИКЛЕ FOR
     * 
     * В цикле for можно объявлять несколько переменных в инициализации
     * и выполнять несколько операций в обновлении.
     * 
     * Синтаксис:
     * for (объявление1, объявление2; условие; операция1, операция2) { тело }
     * 
     * ВАЖНО: переменные должны быть одного типа или использовать auto
     */
    std::cout << "=== МНОЖЕСТВЕННЫЕ ОБЪЯВЛЕНИЯ В ЦИКЛЕ FOR ===" << std::endl;
    std::cout << "Демонстрация цикла с несколькими переменными:" << std::endl;
    std::cout << std::endl;
    
    /*
     * ПРИМЕР 1: БАЗОВОЕ ИСПОЛЬЗОВАНИЕ МНОЖЕСТВЕННЫХ ОБЪЯВЛЕНИЙ
     * 
     * Объявляем три переменные одного типа (size_t):
     * - counter: счетчик итераций
     * - multiplier: множитель, увеличивающийся на 5
     * - decrementer: уменьшающееся значение
     */
    for (size_t counter{0}, multiplier{5}, decrementer{22}; 
         decrementer > 15; 
         ++counter, multiplier += 5, --decrementer) {
        
        std::cout << "Итерация " << counter 
                  << ", множитель: " << multiplier 
                  << ", уменьшающееся: " << decrementer << std::endl;
    }
    
    std::cout << "Цикл завершен!" << std::endl;
    std::cout << std::endl;

    /*
     * ПРИМЕР 2: ПРАКТИЧЕСКОЕ ПРИМЕНЕНИЕ - ОБРАБОТКА МАССИВОВ
     * 
     * Множественные объявления полезны при работе с массивами,
     * когда нужно отслеживать несколько индексов или значений
     */
    std::cout << "=== ПРАКТИЧЕСКОЕ ПРИМЕНЕНИЕ - ОБРАБОТКА МАССИВОВ ===" << std::endl;
    std::cout << "Симуляция обработки массива с двумя индексами:" << std::endl;
    
    const int array_size = 5;
    for (int left_index = 0, right_index = array_size - 1; 
         left_index < right_index; 
         ++left_index, --right_index) {
        
        std::cout << "Обрабатываем элементы [" << left_index 
                  << "] и [" << right_index << "]" << std::endl;
    }
    
    std::cout << "Обработка завершена!" << std::endl;
    std::cout << std::endl;

    /*
     * ПРИМЕР 3: МАТЕМАТИЧЕСКИЕ ВЫЧИСЛЕНИЯ
     * 
     * Множественные переменные полезны для математических вычислений,
     * где нужно отслеживать несколько значений одновременно
     */
    std::cout << "=== МАТЕМАТИЧЕСКИЕ ВЫЧИСЛЕНИЯ ===" << std::endl;
    std::cout << "Вычисление последовательности Фибоначчи:" << std::endl;
    
    for (int i = 0, prev = 0, curr = 1; 
         i < 8; 
         ++i, prev = curr, curr = prev + curr) {
        
        std::cout << "F(" << i << ") = " << prev << std::endl;
    }
    
    std::cout << "Последовательность завершена!" << std::endl;
    std::cout << std::endl;

    /*
     * ПРИМЕР 4: СЛОЖНЫЕ УСЛОВИЯ И ОПЕРАЦИИ
     * 
     * Демонстрация сложных условий и множественных операций
     * в одном цикле
     */
    std::cout << "=== СЛОЖНЫЕ УСЛОВИЯ И ОПЕРАЦИИ ===" << std::endl;
    std::cout << "Цикл с несколькими условиями и операциями:" << std::endl;
    
    for (int x = 0, y = 10, z = 20; 
         x < 5 && y > 0 && z > 10; 
         ++x, y -= 2, z -= 3) {
        
        std::cout << "x: " << x << ", y: " << y << ", z: " << z 
                  << " (сумма: " << (x + y + z) << ")" << std::endl;
    }
    
    std::cout << "Сложный цикл завершен!" << std::endl;
    std::cout << std::endl;

    /*
     * РЕКОМЕНДАЦИИ ПО ИСПОЛЬЗОВАНИЮ МНОЖЕСТВЕННЫХ ОБЪЯВЛЕНИЙ
     * 
     * Практические советы для эффективного использования
     */
    std::cout << "=== РЕКОМЕНДАЦИИ ===" << std::endl;
    std::cout << "1. Используйте множественные объявления для связанных переменных" << std::endl;
    std::cout << "2. Выбирайте осмысленные имена для всех переменных" << std::endl;
    std::cout << "3. Избегайте слишком сложных выражений в цикле" << std::endl;
    std::cout << "4. Используйте auto для переменных разных типов" << std::endl;
    std::cout << "5. Документируйте сложную логику циклов" << std::endl;
    std::cout << "6. Рассмотрите разделение на несколько циклов для сложных случаев" << std::endl;
    std::cout << "7. Проверяйте читаемость кода" << std::endl;
    std::cout << std::endl;
    
    return 0;
}

/*
 * РЕЗЮМЕ: МНОЖЕСТВЕННЫЕ ОБЪЯВЛЕНИЯ В ЦИКЛЕ FOR В C++
 * 
 * 1. ОСНОВНЫЕ ПОНЯТИЯ:
 *    - Можно объявлять несколько переменных в инициализации
 *    - Можно выполнять несколько операций в обновлении
 *    - Переменные должны быть одного типа или использовать auto
 * 
 * 2. СИНТАКСИС:
 *    - for (тип var1{val1}, var2{val2}; условие; op1, op2) { тело }
 *    - Запятые разделяют объявления и операции
 *    - Точка с запятой разделяет части цикла
 * 
 * 3. ОГРАНИЧЕНИЯ:
 *    - Все переменные в инициализации должны быть одного типа
 *    - Или использовать auto для автоматического вывода типов
 *    - Сложность может снижать читаемость кода
 * 
 * 4. ПРАКТИЧЕСКИЕ ПРИМЕНЕНИЯ:
 *    - Обработка массивов с несколькими индексами
 *    - Математические вычисления с несколькими переменными
 *    - Алгоритмы с несколькими счетчиками
 *    - Сложные итерации с множественными условиями
 * 
 * 5. ПРЕИМУЩЕСТВА:
 *    - Компактность кода
 *    - Группировка связанных переменных
 *    - Эффективность (все переменные в одной области видимости)
 *    - Удобство для сложных алгоритмов
 * 
 * 6. НЕДОСТАТКИ:
 *    - Может снижать читаемость
 *    - Сложность отладки
 *    - Потенциальные ошибки в сложных выражениях
 *    - Трудность понимания для новичков
 * 
 * 7. РЕКОМЕНДАЦИИ:
 *    - Используйте для логически связанных переменных
 *    - Выбирайте осмысленные имена
 *    - Избегайте чрезмерной сложности
 *    - Документируйте сложную логику
 *    - Рассмотрите альтернативы для очень сложных случаев
 * 
 * 8. ВАЖНЫЕ ЗАМЕЧАНИЯ:
 *    - Порядок выполнения операций в обновлении слева направо
 *    - Все переменные имеют одинаковую область видимости
 *    - auto выводит тип по первой переменной
 *    - Сложные условия могут быть трудными для понимания
 * 
 * 9. АЛЬТЕРНАТИВЫ:
 *    - Разделение на несколько циклов
 *    - Использование функций для сложной логики
 *    - Структуры данных для группировки переменных
 *    - Обычные циклы с явными объявлениями
 * 
 * 10. ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ:
 *     - Structured bindings (C++17) для работы с парами и кортежами
 *     - Range-based for для итерации по контейнерам
 *     - Алгоритмы STL для стандартных операций
 *     - Лямбда-функции для сложной логики
 */