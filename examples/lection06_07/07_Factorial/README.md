# 07_Factorial - Вычисление факториала различными способами

## Описание примера

Этот пример демонстрирует **четыре различных способа вычисления факториала** в C++ и сравнивает их производительность. Пример показывает разницу между вычислениями на этапе компиляции и во время выполнения программы.

## Ключевые концепции

### 1. Функции-шаблоны с рекурсией
```cpp
template <uint64_t value> 
uint64_t Factorial() {
    return Factorial<value-1>() * value;    
}
```
- Рекурсивная функция-шаблон
- Выполняется во время выполнения программы
- Использует специализацию для базового случая

### 2. Метафункции (классы-шаблоны)
```cpp
template<uint64_t n>
struct fact {
    static const uint64_t value = fact<n-1>::value * n;
};
```
- Вычисления происходят на этапе компиляции
- Использует статические константные поля
- Самый быстрый способ выполнения

### 3. Функции с if constexpr
```cpp
template<uint64_t n>
uint64_t cool_factorial() {
    if constexpr (n > 1) {
        return cool_factorial<n-1>() * n;
    } else {
        return 1ull;
    }
}
```
- Условная компиляция с помощью `if constexpr`
- Условие проверяется на этапе компиляции
- Современный C++17 подход

### 4. Обычный цикл (для сравнения)
```cpp
uint64_t factorial_result = 1;
for(int i = 1; i <= 50; i++) {
    factorial_result *= i;
}
```
- Традиционный способ вычисления
- Выполняется во время выполнения программы

## Особенности реализации

### Специализация шаблонов
- **Полная специализация** для базового случая рекурсии
- Остановка рекурсии на значении 1

### Измерение производительности
- Использование `std::chrono::high_resolution_clock`
- Измерение времени в микросекундах
- Сравнение производительности разных подходов

### Компиляция и оптимизация
- Использование флага `-O2` для оптимизации
- Метафункции должны показывать 0 микросекунд (вычисления на этапе компиляции)

## Ожидаемые результаты

1. **Метафункция (способ 2)** - 0 микросекунд (вычисления на этапе компиляции)
2. **Функция с if constexpr (способ 3)** - 0 микросекунд (оптимизация компилятора)
3. **Обычный цикл (способ 4)** - 1 микросекунд (быстрое выполнение)
4. **Функция-шаблон (способ 1)** - 2 микросекунд (рекурсивные вызовы)

## Компиляция и запуск

```bash
# Компиляция
g++ -std=c++17 -O2 -o factorial_program main.cpp

# Запуск
./factorial_program
```

## Образовательная ценность

Этот пример демонстрирует:
- **Различия между вычислениями на этапе компиляции и во время выполнения**
- **Эффективность метафункций** для константных вычислений
- **Современные возможности C++17** (`if constexpr`)
- **Специализацию шаблонов** для рекурсивных алгоритмов
- **Измерение производительности** программ

## Практическое применение

- **Метафункции** используются в библиотеках для вычисления констант на этапе компиляции
- **if constexpr** позволяет создавать более эффективный код
- **Измерение производительности** помогает оптимизировать критические участки кода
- **Специализация шаблонов** полезна для создания эффективных рекурсивных алгоритмов
