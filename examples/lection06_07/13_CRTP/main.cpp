#include <iostream>

// ============================================================================
// ДЕМОНСТРАЦИЯ ПАТТЕРНА CRTP (CURIOSLY RECURRING TEMPLATE PATTERN)
// ============================================================================

// ============================================================================
// БАЗОВЫЙ КЛАСС-ШАБЛОН С CRTP
// ============================================================================

// Базовый класс-шаблон, который использует CRTP
// CHILD - тип производного класса, который наследуется от Base<CHILD>
template <class CHILD> 
class Base {
public:
    // Фасадный метод, который делегирует выполнение производному классу
    void facade() noexcept {
        try{
            // Статическое приведение к типу производного класса
            // Это ключевая особенность CRTP - статический полиморфизм
            static_cast<CHILD*>(this)->do_action();
        }catch(...){
            std::cout << "Обработка исключения в базовом классе" << std::endl;
        }
    }
    
    // Дополнительный метод для демонстрации CRTP
    void perform_operation() noexcept {
        try{
            // Вызов метода производного класса
            static_cast<CHILD*>(this)->specific_operation();
        }catch(...){
            std::cout << "Ошибка при выполнении операции" << std::endl;
        }
    }
};

// ============================================================================
// ПРОИЗВОДНЫЙ КЛАСС, ИСПОЛЬЗУЮЩИЙ CRTP
// ============================================================================

// Производный класс, который наследуется от Base<Child>
// Это создает "странно рекурсивный" шаблон
class Child : public Base<Child> {
    // Дружественный класс для доступа к защищенным методам
    friend Base<Child>;
    
protected: 
    // Конкретная реализация действия
    void do_action() {
        std::cout << "Выполнение действия в производном классе" << std::endl;
    }
    
    // Дополнительная операция для демонстрации
    void specific_operation() {
        std::cout << "Специфическая операция производного класса" << std::endl;
    }
};

// ============================================================================
// ДОПОЛНИТЕЛЬНЫЙ ПРОИЗВОДНЫЙ КЛАСС ДЛЯ ДЕМОНСТРАЦИИ
// ============================================================================

// Еще один производный класс для демонстрации гибкости CRTP
class AnotherChild : public Base<AnotherChild> {
    friend Base<AnotherChild>;
    
protected:
    void do_action() {
        std::cout << "Альтернативная реализация действия" << std::endl;
    }
    
    void specific_operation() {
        std::cout << "Альтернативная специфическая операция" << std::endl;
    }
};

// ============================================================================
// ОСНОВНАЯ ФУНКЦИЯ - ДЕМОНСТРАЦИЯ CRTP
// ============================================================================

int main() {
    std::cout << "=== ДЕМОНСТРАЦИЯ ПАТТЕРНА CRTP ===" << std::endl << std::endl;
    
    // ========================================================================
    // ДЕМОНСТРАЦИЯ 1: ОСНОВНОЕ ИСПОЛЬЗОВАНИЕ CRTP
    // ========================================================================
    std::cout << "1. Основное использование CRTP:" << std::endl;
    Child child_instance;
    child_instance.facade();
    child_instance.perform_operation();
    std::cout << std::endl;
    
    // ========================================================================
    // ДЕМОНСТРАЦИЯ 2: РАЗНЫЕ ПРОИЗВОДНЫЕ КЛАССЫ
    // ========================================================================
    std::cout << "2. Разные производные классы:" << std::endl;
    AnotherChild another_child_instance;
    another_child_instance.facade();
    another_child_instance.perform_operation();
    std::cout << std::endl;
    
    // ========================================================================
    // ДЕМОНСТРАЦИЯ 3: ОБЪЯСНЕНИЕ ПРИНЦИПА РАБОТЫ
    // ========================================================================
    std::cout << "3. Принцип работы CRTP:" << std::endl;
    std::cout << "   - Базовый класс знает тип производного класса" << std::endl;
    std::cout << "   - static_cast<CHILD*>(this) - статическое приведение" << std::endl;
    std::cout << "   - Вызов методов происходит без виртуальных функций" << std::endl;
    std::cout << "   - Нет накладных расходов на виртуальные таблицы" << std::endl;
    std::cout << "   - Статический полиморфизм на этапе компиляции" << std::endl << std::endl;
    
    // ========================================================================
    // ДЕМОНСТРАЦИЯ 4: ПРЕИМУЩЕСТВА CRTP
    // ========================================================================
    std::cout << "4. Преимущества CRTP:" << std::endl;
    std::cout << "   - Отсутствие накладных расходов на виртуальные функции" << std::endl;
    std::cout << "   - Статический полиморфизм" << std::endl;
    std::cout << "   - Возможность инлайн-оптимизации" << std::endl;
    std::cout << "   - Безопасность типов на этапе компиляции" << std::endl;
    std::cout << "   - Использование в библиотеках (например, std::enable_shared_from_this)" << std::endl;
    
    return 0;
}