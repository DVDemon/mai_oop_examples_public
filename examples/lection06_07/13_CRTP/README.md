# 13_CRTP - Паттерн CRTP (Curiously Recurring Template Pattern)

## Описание примера

Этот пример демонстрирует **паттерн CRTP (Curiously Recurring Template Pattern)** - один из самых мощных паттернов в C++ для статического полиморфизма. Показывает, как базовый класс может вызывать методы производного класса без использования виртуальных функций.

## Ключевые концепции

### 1. Структура CRTP
```cpp
template <class CHILD> 
class Base {
public:
    void facade() noexcept {
        static_cast<CHILD*>(this)->do_action();
    }
};

class Child : public Base<Child> {
    friend Base<Child>;
protected: 
    void do_action() { /* ... */ }
};
```
- **Базовый класс-шаблон** с параметром типа производного класса
- **Производный класс** наследуется от Base<Child>
- **static_cast<CHILD*>(this)** - ключевая особенность CRTP

### 2. Статический полиморфизм
- **Отсутствие виртуальных функций** - нет накладных расходов
- **Статическое приведение типов** - безопасность на этапе компиляции
- **Инлайн-оптимизация** - компилятор может оптимизировать вызовы

### 3. Преимущества CRTP
- **Производительность** - нет накладных расходов на виртуальные таблицы
- **Безопасность типов** - проверка на этапе компиляции
- **Гибкость** - возможность переопределения методов в производных классах

## Особенности реализации

### Ключевые элементы CRTP
- **template <class CHILD>** - параметр шаблона для типа производного класса
- **static_cast<CHILD*>(this)** - приведение к типу производного класса
- **friend Base<Child>** - дружественный класс для доступа к защищенным методам

### Статический полиморфизм
- **Вызов методов** происходит без виртуальных функций
- **Компилятор знает** точный тип объекта на этапе компиляции
- **Возможность инлайн-оптимизации** вызовов методов

### Безопасность типов
- **Проверка типов** на этапе компиляции
- **Ошибки компиляции** при неправильном использовании
- **Статическая проверка** корректности наследования

## Ожидаемые результаты

```
=== ДЕМОНСТРАЦИЯ ПАТТЕРНА CRTP ===

1. Основное использование CRTP:
Выполнение действия в производном классе
Специфическая операция производного класса

2. Разные производные классы:
Альтернативная реализация действия
Альтернативная специфическая операция

3. Принцип работы CRTP:
   - Базовый класс знает тип производного класса
   - static_cast<CHILD*>(this) - статическое приведение
   - Вызов методов происходит без виртуальных функций
   - Нет накладных расходов на виртуальные таблицы
   - Статический полиморфизм на этапе компиляции

4. Преимущества CRTP:
   - Отсутствие накладных расходов на виртуальные функции
   - Статический полиморфизм
   - Возможность инлайн-оптимизации
   - Безопасность типов на этапе компиляции
   - Использование в библиотеках (например, std::enable_shared_from_this)
```

## Компиляция и запуск

```bash
# Компиляция
g++ -std=c++17 -O2 -o crtp_program main.cpp

# Запуск
./crtp_program
```

## Образовательная ценность

Этот пример демонстрирует:
- **Паттерн CRTP** - один из самых важных паттернов в C++
- **Статический полиморфизм** без виртуальных функций
- **Производительность** - отсутствие накладных расходов
- **Безопасность типов** на этапе компиляции
- **Практическое применение** в реальных проектах

## Практическое применение

### Стандартная библиотека C++
- **std::enable_shared_from_this** - использует CRTP
- **std::iterator** - базовый класс для итераторов
- **Многие библиотеки** используют CRTP для оптимизации

### Библиотеки
- **Boost** - множество классов используют CRTP
- **Eigen** - математическая библиотека
- **Собственные библиотеки** - для оптимизации производительности

### Когда использовать CRTP
- **Критическая производительность** - когда важна скорость
- **Статический полиморфизм** - когда нужен полиморфизм без виртуальных функций
- **Инлайн-оптимизация** - когда компилятор должен оптимизировать вызовы

## Связь с другими примерами

- **12_ConceptsExample2** - сложные концепции C++20
- **11_ConceptsExample1** - пользовательские концепции
- **10_BuiltInConcepts** - встроенные концепции
- **06_Metafunction** - метафункции и вычисления на этапе компиляции

## Сравнение с виртуальными функциями

### Виртуальные функции
```cpp
class Base {
public:
    virtual void do_action() = 0;  // Виртуальная функция
};

class Child : public Base {
public:
    void do_action() override { /* ... */ }
};
```

### CRTP
```cpp
template <class CHILD>
class Base {
public:
    void facade() {
        static_cast<CHILD*>(this)->do_action();  // Статический вызов
    }
};

class Child : public Base<Child> {
    friend Base<Child>;
protected:
    void do_action() { /* ... */ }
};
```

## Дополнительные возможности

### Множественное наследование с CRTP
```cpp
template <class CHILD>
class Base1 { /* ... */ };

template <class CHILD>
class Base2 { /* ... */ };

class Child : public Base1<Child>, public Base2<Child> {
    // ...
};
```

### CRTP с концепциями (C++20)
```cpp
template <class CHILD>
requires std::derived_from<CHILD, Base<CHILD>>
class Base {
    // ...
};
```

### Измерение производительности
```cpp
// CRTP - быстрее, нет накладных расходов
// Виртуальные функции - медленнее, есть накладные расходы
```
