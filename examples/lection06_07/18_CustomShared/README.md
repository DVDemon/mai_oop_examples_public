# 18_CustomShared - Пользовательский shared_ptr

## Описание примера

Этот пример демонстрирует создание **пользовательского shared_ptr** - упрощенной версии std::shared_ptr с разделяемым владением. Показывает, как реализовать автоматическое управление памятью с использованием счетчика ссылок (reference counting).

## Ключевые концепции

### 1. Структура пользовательского shared_ptr
```cpp
template<class T>
struct smart_ptr {
    T* m_ptr;                    // Сырой указатель на управляемый объект
    std::size_t* m_counter;      // Счетчик ссылок (разделяется между копиями)
    
    // Конструкторы
    smart_ptr(T* raw_pointer);
    smart_ptr(const smart_ptr& other);
    
    // Деструктор
    ~smart_ptr();
    
    // Методы доступа
    T* get() const;
    std::size_t use_count() const;
    bool is_valid() const;
};
```

### 2. Принципы работы счетчика ссылок
- **Разделяемое владение** - несколько smart_ptr могут владеть одним объектом
- **Счетчик ссылок** - автоматическое управление жизненным циклом
- **Копирование** - увеличивает счетчик ссылок
- **Уничтожение** - уменьшает счетчик ссылок
- **Освобождение** - объект удаляется при счетчике = 0

### 3. Конструкторы и деструктор
```cpp
// Конструктор с сырым указателем - создает новый счетчик
smart_ptr(T* raw_pointer) 
    : m_counter{new std::size_t{1}},  // Создание нового счетчика
      m_ptr{raw_pointer} {           // Сохранение указателя
}

// Копирующий конструктор - увеличивает счетчик
smart_ptr(const smart_ptr& other) 
    : m_counter{other.m_counter},    // Разделение счетчика
      m_ptr{other.m_ptr} {           // Разделение указателя
    ++(*m_counter);                  // Увеличение счетчика
}

// Деструктор - уменьшает счетчик и освобождает ресурсы
~smart_ptr() {
    if (--(*m_counter) == 0) {
        delete m_ptr;        // Освобождение объекта
        delete m_counter;    // Освобождение счетчика
    }
}
```

## Особенности реализации

### Счетчик ссылок
- **Разделение счетчика** - все копии указывают на один счетчик
- **Атомарные операции** - в реальной реализации нужны для thread-safety
- **Автоматическое освобождение** - при счетчике = 0
- **Управление счетчиком** - освобождение вместе с объектом

### Конструкторы
- **С сырым указателем** - создает новый счетчик
- **Копирующий** - разделяет существующий счетчик
- **Увеличение счетчика** - при каждом копировании

### Деструктор
- **Уменьшение счетчика** - при каждом уничтожении
- **Проверка на ноль** - освобождение только при последнем владельце
- **Освобождение ресурсов** - объекта и счетчика

## Ожидаемые результаты

```
=== ДЕМОНСТРАЦИЯ ПОЛЬЗОВАТЕЛЬСКОГО SHARED_PTR ===

Демонстрация разделяемого владения:
start
SomeStruct constructor called
   shared_pointer_1 created, reference count: 1
Reference count increased to: 2
   shared_pointer_2 created, reference count: 2
Reference count increased to: 3
   shared_pointer_3 created, reference count: 3
   All pointers point to the same object: 1
Destructor called, reference count: 3
Destructor called, reference count: 2
   shared_pointer_3 destroyed, reference count: 1
Destructor called, reference count: 1
SomeStruct destructor called
   All shared_ptrs destroyed, object should be deallocated
end

Принципы работы пользовательского shared_ptr:
   - Разделяемое владение ресурсом
   - Счетчик ссылок (reference counting)
   - Автоматическое освобождение при последнем владельце
   - Копирование увеличивает счетчик
   - Уничтожение уменьшает счетчик
   - Объект освобождается только при счетчике = 0
```

## Компиляция и запуск

```bash
# Компиляция
g++ -std=c++17 -O2 -o custom_shared_program main.cpp

# Запуск
./custom_shared_program
```

## Образовательная ценность

Этот пример демонстрирует:
- **Создание пользовательского shared_ptr** - понимание принципов работы
- **Счетчик ссылок** - автоматическое управление жизненным циклом
- **Разделяемое владение** - несколько владельцев одного ресурса
- **RAII принцип** - управление ресурсами через конструкторы/деструкторы
- **Автоматическое управление памятью** - исключение утечек

## Практическое применение

### Понимание std::shared_ptr
- **Принципы работы** - как работает стандартный shared_ptr
- **Реализация** - что происходит под капотом
- **Оптимизация** - понимание накладных расходов

### Создание собственных умных указателей
- **Специализированные счетчики** - для особых случаев
- **Дополнительная функциональность** - специфичные методы
- **Интеграция с API** - совместимость с существующим кодом

### Изучение паттернов
- **RAII** - Resource Acquisition Is Initialization
- **Reference counting** - подсчет ссылок
- **Template programming** - работа с шаблонами

## Сравнение с std::shared_ptr

### Пользовательский smart_ptr
```cpp
smart_ptr<SomeStruct> ptr{new SomeStruct};
// Простая реализация
// Образовательные цели
// Базовая функциональность
```

### std::shared_ptr
```cpp
std::shared_ptr<SomeStruct> ptr = std::make_shared<SomeStruct>();
// Полная функциональность
// Оптимизированная реализация
// Производственное использование
```

## Ограничения и особенности

### Ограничения пользовательской реализации
- **Базовая функциональность** - не все возможности std::shared_ptr
- **Производительность** - может быть менее оптимизирована
- **Thread-safety** - отсутствует в простой реализации
- **Совместимость** - может не работать с некоторыми API

### Особенности реализации
- **Образовательные цели** - понимание принципов работы
- **Простота** - легко понять и модифицировать
- **Расширяемость** - можно добавить дополнительную функциональность

## Дополнительные возможности

### Расширенная функциональность
```cpp
template<class T>
struct advanced_smart_ptr {
    // Операторы доступа
    T& operator*() { return *m_ptr; }
    T* operator->() { return m_ptr; }
    
    // Проверка валидности
    explicit operator bool() const { return m_ptr != nullptr; }
    
    // Оператор присваивания
    smart_ptr& operator=(const smart_ptr& other) {
        if (this != &other) {
            // Уменьшение текущего счетчика
            if (--(*m_counter) == 0) {
                delete m_ptr;
                delete m_counter;
            }
            
            // Разделение нового счетчика
            m_counter = other.m_counter;
            m_ptr = other.m_ptr;
            ++(*m_counter);
        }
        return *this;
    }
};
```

### Thread-safe версия
```cpp
template<class T>
struct thread_safe_smart_ptr {
    std::atomic<std::size_t>* m_counter;
    T* m_ptr;
    
    // Атомарные операции для thread-safety
    void increment() {
        m_counter->fetch_add(1, std::memory_order_relaxed);
    }
    
    bool decrement() {
        return m_counter->fetch_sub(1, std::memory_order_acq_rel) == 1;
    }
};
```

### Кастомные делетеры
```cpp
template<class T, class Deleter = std::default_delete<T>>
struct custom_smart_ptr {
    Deleter deleter;
    
    ~custom_smart_ptr() {
        if (--(*m_counter) == 0) {
            deleter(m_ptr);
            delete m_counter;
        }
    }
};
```

## Связь с другими примерами

- **17_SharedPtr** - стандартный std::shared_ptr
- **16_CustomUniquePointer** - пользовательский unique_ptr
- **15_UniquePointers** - std::unique_ptr
- **14_VariadicTemplate** - variadic templates C++11

## Рекомендации по изучению

### Этапы изучения
1. **Понимание принципов** - разделяемое владение, счетчик ссылок
2. **Реализация базовой версии** - конструкторы, деструктор
3. **Добавление методов доступа** - get(), use_count(), is_valid()
4. **Тестирование** - проверка корректности работы
5. **Оптимизация** - улучшение производительности

### Практические упражнения
- **Добавление операторов** - operator*, operator->
- **Реализация operator=** - оператор присваивания
- **Добавление thread-safety** - атомарные операции
- **Создание make_smart_ptr()** - аналог std::make_shared
- **Добавление weak_ptr** - для предотвращения циклических ссылок

## Дополнительные возможности

### Интеграция с STL
```cpp
std::vector<smart_ptr<int>> container;
container.push_back(smart_ptr<int>{new int{42}});

// Сортировка по значению
std::sort(container.begin(), container.end(), 
    [](const auto& a, const auto& b) { return *a < *b; });
```

### Многопоточность
```cpp
smart_ptr<SomeStruct> shared = smart_ptr<SomeStruct>{new SomeStruct};

// Безопасное использование в разных потоках (с thread-safe версией)
std::thread t1([shared]() { /* use shared */ });
std::thread t2([shared]() { /* use shared */ });
```

### Отладка и профилирование
```cpp
template<class T>
struct debug_smart_ptr {
    void debug_info() const {
        std::cout << "Pointer: " << m_ptr << std::endl;
        std::cout << "Reference count: " << *m_counter << std::endl;
        std::cout << "Valid: " << is_valid() << std::endl;
    }
};
```

## Ограничения и предупреждения

### Ограничения простой реализации
- **Отсутствие thread-safety** - не безопасно в многопоточности
- **Отсутствие операторов** - нет operator*, operator->
- **Отсутствие operator=** - нет оператора присваивания
- **Отсутствие weak_ptr** - нет защиты от циклических ссылок

### Предупреждения
- **Не для продакшена** - только для образовательных целей
- **Проверка производительности** - может быть медленнее std::shared_ptr
- **Тестирование** - необходимо тщательное тестирование
- **Документация** - необходимо документировать все особенности

## Рекомендации по использованию

### Лучшие практики
1. **Используйте для обучения** - понимание принципов работы
2. **Добавляйте функциональность** - постепенно расширяйте возможности
3. **Тестируйте тщательно** - проверяйте все сценарии использования
4. **Документируйте** - описывайте все особенности реализации

### Антипаттерны
- **Использование в продакшене** - без тщательного тестирования
- **Игнорирование thread-safety** - в многопоточных приложениях
- **Отсутствие тестирования** - без проверки всех сценариев
- **Копирование без понимания** - без изучения принципов работы
