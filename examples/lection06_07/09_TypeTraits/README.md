# 09_TypeTraits - Стандартные Type Traits и std::enable_if

## Описание примера

Этот пример демонстрирует использование **стандартных type traits** из библиотеки `<type_traits>` и **std::enable_if** для условной компиляции. Показывает, как создавать функции, которые активируются только для определенных типов.

## Ключевые концепции

### 1. std::enable_if - Условная компиляция
```cpp
template <class T>
typename std::enable_if<std::is_array<T>::value, void>::type print(T& array_value) {
    // Код выполняется только если T является массивом
}
```
- **std::enable_if<condition, type>** - условная компиляция
- **condition** - условие, которое проверяется на этапе компиляции
- **type** - тип, который возвращается, если условие истинно

### 2. Стандартные Type Traits
```cpp
std::is_array<T>::value      // Проверка, является ли T массивом
std::is_pointer<T>::value    // Проверка, является ли T указателем
std::is_integral<T>::value   // Проверка, является ли T целочисленным
```
- **std::is_array** - проверка массивов
- **std::is_pointer** - проверка указателей
- **std::is_integral** - проверка целочисленных типов

### 3. Альтернативный способ с параметром шаблона
```cpp
template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0> 
void print_integer(T integer_value) { 
    // Код выполняется только для целочисленных типов
}
```
- **Параметр шаблона по умолчанию** с enable_if
- **Более гибкий** способ условной компиляции

## Особенности реализации

### Условная компиляция
- **std::enable_if** активирует код только при выполнении условия
- **Компилятор выбирает** подходящую версию функции
- **Ошибки компиляции** при несовместимых типах

### Type Traits
- **Проверка свойств типов** на этапе компиляции
- **Стандартная библиотека** предоставляет множество traits
- **Компилятор оптимизирует** неиспользуемый код

### Безопасность типов
- **Предотвращение ошибок** на этапе компиляции
- **Явное указание** требований к типам
- **Документирование** ограничений функций

## Ожидаемые результаты

```
=== ДЕМОНСТРАЦИЯ TYPE TRAITS И STD::ENABLE_IF ===

1. Печать целочисленных типов:
Целое число: 10
Целочисленное значение: 10
   (print_integer(d) закомментировано - double не является целочисленным типом)

2. Печать массивов:
Массив: 1 2 3 4 5 

3. Печать указателей:
Указатель: 0x2bcc92c0

4. Принцип работы:
   - std::enable_if<condition, type> - условная компиляция
   - std::is_array<T>::value - проверка, является ли T массивом
   - std::is_pointer<T>::value - проверка, является ли T указателем
   - std::is_integral<T>::value - проверка, является ли T целочисленным
   - Компилятор выбирает подходящую версию функции на этапе компиляции
```

## Компиляция и запуск

```bash
# Компиляция
g++ -std=c++17 -O2 -o type_traits_program main.cpp

# Запуск
./type_traits_program
```

## Образовательная ценность

Этот пример демонстрирует:
- **Стандартные type traits** из библиотеки `<type_traits>`
- **std::enable_if** для условной компиляции
- **Безопасность типов** на этапе компиляции
- **Альтернативные способы** условной компиляции
- **Оптимизацию компилятора** для неиспользуемого кода

## Практическое применение

- **Библиотеки** используют type traits для оптимизации
- **STL** содержит множество стандартных type traits
- **Безопасность типов** предотвращает ошибки во время выполнения
- **Условная компиляция** позволяет создавать эффективный код

## Связь с другими примерами

- **08_Types** - создание собственных type traits
- **04_Specialization** - специализация шаблонов
- **05_PartialSpecialization** - частичная специализация
- **06_Metafunction** - метафункции и вычисления на этапе компиляции

## Дополнительные возможности

### Другие стандартные Type Traits
```cpp
std::is_same<T, U>::value        // Проверка на одинаковость типов
std::is_convertible<T, U>::value // Проверка на возможность преобразования
std::is_const<T>::value         // Проверка на константность
std::is_reference<T>::value     // Проверка на ссылку
```

### Современные альтернативы
```cpp
// C++17: if constexpr
if constexpr (std::is_integral_v<T>) {
    // Код для целочисленных типов
}

// C++20: concepts
template<typename T>
requires std::integral<T>
void print_integer(T value) {
    // Код для целочисленных типов
}
```
