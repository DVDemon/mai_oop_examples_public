#include <type_traits>
#include <iostream>

// ============================================================================
// ДЕМОНСТРАЦИЯ TYPE TRAITS И STD::ENABLE_IF
// ============================================================================

// ============================================================================
// ФУНКЦИЯ 1: ПЕЧАТЬ МАССИВОВ
// ============================================================================

// Функция для печати массивов
// Активируется только если T является массивом
template <class T>
typename std::enable_if<std::is_array<T>::value, void>::type print(T& array_value) {
    std::cout << "Массив: ";
    for(auto element : array_value) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
}

// ============================================================================
// ФУНКЦИЯ 2: ПЕЧАТЬ УКАЗАТЕЛЕЙ
// ============================================================================

// Функция для печати указателей
// Активируется только если T является указателем
template <class T>
typename std::enable_if<std::is_pointer<T>::value, void>::type print(T& pointer_value) {
    std::cout << "Указатель: " << pointer_value << std::endl;
}

// ============================================================================
// ФУНКЦИЯ 3: ПЕЧАТЬ ЦЕЛОЧИСЛЕННЫХ ТИПОВ
// ============================================================================

// Функция для печати целочисленных типов
// Активируется только если T является целочисленным типом
template <class T>
typename std::enable_if<std::is_integral<T>::value, void>::type print(T& integer_value) {
    std::cout << "Целое число: " << integer_value << std::endl;
}

// ============================================================================
// ФУНКЦИЯ 4: ПЕЧАТЬ ТОЛЬКО ЦЕЛОЧИСЛЕННЫХ ТИПОВ (АЛЬТЕРНАТИВНЫЙ СПОСОБ)
// ============================================================================

// Функция, которая работает только с целочисленными типами
// Использует параметр шаблона по умолчанию с enable_if
template<typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0> 
void print_integer(T integer_value) { 
    std::cout << "Целочисленное значение: " << integer_value << std::endl; 
}

// ============================================================================
// ОСНОВНАЯ ФУНКЦИЯ - ДЕМОНСТРАЦИЯ TYPE TRAITS
// ============================================================================

int main() {
    std::cout << "=== ДЕМОНСТРАЦИЯ TYPE TRAITS И STD::ENABLE_IF ===" << std::endl << std::endl;
    
    // ========================================================================
    // ДЕМОНСТРАЦИЯ 1: ПЕЧАТЬ ЦЕЛОЧИСЛЕННЫХ ТИПОВ
    // ========================================================================
    std::cout << "1. Печать целочисленных типов:" << std::endl;
    int integer_value = 10;
    double double_value = 1.0;
    
    print(integer_value);  // Вызовется версия для целочисленных типов
    print_integer<int>(integer_value);  // Альтернативный способ
    
    // print_integer(d);  // Ошибка компиляции - double не является целочисленным типом
    std::cout << "   (print_integer(d) закомментировано - double не является целочисленным типом)" << std::endl << std::endl;
    
    // ========================================================================
    // ДЕМОНСТРАЦИЯ 2: ПЕЧАТЬ МАССИВОВ
    // ========================================================================
    std::cout << "2. Печать массивов:" << std::endl;
    int array_data[5] = {1, 2, 3, 4, 5};
    print(array_data);  // Вызовется версия для массивов
    std::cout << std::endl;
    
    // ========================================================================
    // ДЕМОНСТРАЦИЯ 3: ПЕЧАТЬ УКАЗАТЕЛЕЙ
    // ========================================================================
    std::cout << "3. Печать указателей:" << std::endl;
    int* pointer_data = new int[10];
    print(pointer_data);  // Вызовется версия для указателей
    
    // Освобождение памяти
    delete[] pointer_data;
    std::cout << std::endl;
    
    // ========================================================================
    // ДЕМОНСТРАЦИЯ 4: ОБЪЯСНЕНИЕ ПРИНЦИПА РАБОТЫ
    // ========================================================================
    std::cout << "4. Принцип работы:" << std::endl;
    std::cout << "   - std::enable_if<condition, type> - условная компиляция" << std::endl;
    std::cout << "   - std::is_array<T>::value - проверка, является ли T массивом" << std::endl;
    std::cout << "   - std::is_pointer<T>::value - проверка, является ли T указателем" << std::endl;
    std::cout << "   - std::is_integral<T>::value - проверка, является ли T целочисленным" << std::endl;
    std::cout << "   - Компилятор выбирает подходящую версию функции на этапе компиляции" << std::endl;
    
    return 0;
}