# 10_BuiltInConcepts - Встроенные концепции C++20

## Описание примера

Этот пример демонстрирует использование **встроенных концепций C++20** для ограничения типов в шаблонах. Показывает, как концепции заменяют сложные SFINAE конструкции и делают код более читаемым и понятным.

## Ключевые концепции

### 1. std::is_default_constructible_v<T>
```cpp
template <typename T>
requires std::is_default_constructible_v<T>
class BoxContainer
```
- **Проверяет**, что тип T может быть создан по умолчанию
- **Используется** для ограничения типов в шаблонах
- **Заменяет** сложные SFINAE конструкции

### 2. std::is_arithmetic_v<T>
```cpp
template <typename T>
requires std::is_arithmetic_v<T>
class Point
```
- **Проверяет**, что тип T является арифметическим
- **Включает** целочисленные и типы с плавающей точкой
- **Обеспечивает** безопасность типов

### 3. std::copyable<T>
```cpp
BoxContainer(const BoxContainer& source) requires std::copyable<T>;
```
- **Проверяет**, что тип T может быть скопирован
- **Требует** наличие конструктора копирования
- **Используется** для условной компиляции

## Особенности реализации

### Концепции в шаблонах
- **requires** - ключевое слово для ограничений
- **std::is_*_v** - переменные шаблонов для проверки типов
- **Условная компиляция** на основе свойств типов

### Современный синтаксис C++20
- **Концепции** вместо SFINAE
- **Более читаемые** ограничения типов
- **Лучшие сообщения** об ошибках компиляции

### Практическое применение
- **Ограничение типов** в шаблонах
- **Улучшение читаемости** кода
- **Замена сложных** метапрограммных конструкций

## Встроенные концепции C++20

### Числовые концепции
```cpp
std::is_arithmetic_v<T>      // Арифметические типы
std::floating_point<T>       // Типы с плавающей точкой
std::integral<T>             // Целочисленные типы
```

### Концепции равенства и порядка
```cpp
std::equality_comparable<T>   // Поддерживает == и !=
std::totally_ordered<T>      // Поддерживает все операторы сравнения
```

### Другие концепции
```cpp
std::same_as<T, U>           // Типы одинаковы
std::destructible<T>          // Тип может быть разрушен
std::copyable<T>              // Тип может быть скопирован
std::default_constructible<T> // Тип может быть создан по умолчанию
```

## Ожидаемые результаты

```
=== ДЕМОНСТРАЦИЯ ВСТРОЕННЫХ КОНЦЕПЦИЙ C++20 ===

1. Использование BoxContainer с концепциями:
   Контейнер точек: BoxContainer : [ size :  3, capacity : 5, items : Point [ x : 1, y : 2] Point [ x : 3, y : 4] Point [ x : 5, y : 6] ]

2. Различные встроенные концепции C++20:
   Числовые концепции:
   - std::is_arithmetic_v<T> - арифметические типы
   - std::floating_point<T> - типы с плавающей точкой
   - std::integral<T> - целочисленные типы
   Концепции равенства и порядка:
   - std::equality_comparable<T> - поддерживает == и !=
   - std::totally_ordered<T> - поддерживает все операторы сравнения
   Другие концепции:
   - std::same_as<T, U> - типы одинаковы
   - std::destructible<T> - тип может быть разрушен
   - std::copyable<T> - тип может быть скопирован
   - std::default_constructible<T> - тип может быть создан по умолчанию
```

## Компиляция и запуск

```bash
# Компиляция (требует C++20)
g++ -std=c++20 -O2 -o concepts_program main.cpp

# Запуск
./concepts_program
```

## Образовательная ценность

Этот пример демонстрирует:
- **Встроенные концепции C++20** для ограничения типов
- **Современный синтаксис** вместо SFINAE
- **Улучшение читаемости** кода
- **Лучшие сообщения** об ошибках компиляции
- **Практическое применение** концепций в реальных проектах

## Практическое применение

- **Библиотеки** используют концепции для ограничения типов
- **STL** содержит множество встроенных концепций
- **Замена SFINAE** на более читаемые конструкции
- **Улучшение качества** кода и его понимания

## Связь с другими примерами

- **09_TypeTraits** - стандартные type traits
- **08_Types** - создание собственных type traits
- **06_Metafunction** - метафункции и вычисления на этапе компиляции
- **04_Specialization** - специализация шаблонов

## Современные возможности C++20

### Концепции vs SFINAE
```cpp
// Старый способ (SFINAE)
template<typename T>
typename std::enable_if<std::is_arithmetic<T>::value, void>::type
function(T value) { /* ... */ }

// Новый способ (концепции)
template<typename T>
requires std::is_arithmetic_v<T>
void function(T value) { /* ... */ }
```

### Пользовательские концепции
```cpp
template<typename T>
concept Numeric = std::is_arithmetic_v<T>;

template<Numeric T>
void process(T value) { /* ... */ }
```

### Комбинирование концепций
```cpp
template<typename T>
requires std::is_arithmetic_v<T> && std::copyable<T>
void function(T value) { /* ... */ }
```
