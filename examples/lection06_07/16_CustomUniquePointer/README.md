# 16_CustomUniquePointer - Пользовательский умный указатель

## Описание примера

Этот пример демонстрирует создание **пользовательского умного указателя** - упрощенной версии std::unique_ptr. Показывает, как реализовать автоматическое управление памятью с использованием RAII принципа и move semantics.

## Ключевые концепции

### 1. Структура пользовательского умного указателя
```cpp
template<class T>
struct smart_ptr {
    T* m_ptr;  // Сырой указатель на управляемый объект
    
    // Конструкторы
    smart_ptr();
    smart_ptr(T* raw_pointer);
    
    // Операторы
    smart_ptr& operator=(const smart_ptr&) = delete;  // Запрет копирования
    smart_ptr& operator=(smart_ptr&& other) noexcept;  // Перемещение
    
    // Деструктор
    ~smart_ptr();
    
    // Методы доступа
    T* get();
    bool is_valid() const;
};
```

### 2. Принципы работы умного указателя
- **Единоличное владение** - только один владелец ресурса
- **Автоматическое освобождение** - в деструкторе
- **Запрет копирования** - copy constructor deleted
- **Разрешение перемещения** - move semantics
- **RAII принцип** - управление ресурсами

### 3. Move semantics
```cpp
smart_ptr& operator=(smart_ptr&& other) noexcept {
    if (m_ptr) delete m_ptr;  // Освобождение текущего ресурса
    m_ptr = other.m_ptr;      // Передача владения
    other.m_ptr = nullptr;    // Обнуление источника
    return *this;
}
```
- **Передача владения** - без копирования
- **Обнуление источника** - предотвращение двойного освобождения
- **noexcept** - гарантия отсутствия исключений

## Особенности реализации

### Конструкторы
- **По умолчанию** - создает пустой указатель
- **С сырым указателем** - принимает владение
- **Перемещения** - передача владения

### Операторы
- **Копирование запрещено** - `operator=(const smart_ptr&) = delete`
- **Перемещение разрешено** - `operator=(smart_ptr&&)`
- **noexcept** - гарантия отсутствия исключений

### Деструктор
- **Автоматическое освобождение** - `delete m_ptr`
- **Обнуление указателя** - `m_ptr = nullptr`
- **RAII принцип** - управление жизненным циклом

## Ожидаемые результаты

```
=== ДЕМОНСТРАЦИЯ ПОЛЬЗОВАТЕЛЬСКОГО УМНОГО УКАЗАТЕЛЯ ===

1. Создание и использование умного указателя:
   start
Constructor called
   size of raw pointer = 8 bytes
   size of smart pointer = 8 bytes
   Smart pointer is valid
Destructor called
   end

2. Перемещение владения:
   start
Constructor called
   Source pointer is now invalid (correct)
   Destination pointer is valid (correct)
Destructor called
   end

3. Принципы работы умного указателя:
   - Единоличное владение ресурсом
   - Автоматическое освобождение памяти
   - Запрет копирования (copy constructor deleted)
   - Разрешение перемещения (move semantics)
   - RAII принцип - управление ресурсами

4. Преимущества умного указателя:
   - Исключение утечек памяти
   - Исключение двойного освобождения
   - Исключение висячих указателей
   - Автоматическое управление жизненным циклом
   - Безопасность типов
```

## Компиляция и запуск

```bash
# Компиляция
g++ -std=c++17 -O2 -o custom_unique_pointer_program main.cpp

# Запуск
./custom_unique_pointer_program
```

## Образовательная ценность

Этот пример демонстрирует:
- **Создание пользовательского умного указателя** - понимание принципов работы
- **RAII принцип** - управление ресурсами через конструкторы/деструкторы
- **Move semantics** - перемещение владения вместо копирования
- **Запрет копирования** - предотвращение проблем с владением
- **Автоматическое управление памятью** - исключение утечек

## Практическое применение

### Понимание std::unique_ptr
- **Принципы работы** - как работает стандартный умный указатель
- **Реализация** - что происходит под капотом
- **Оптимизация** - понимание накладных расходов

### Создание собственных умных указателей
- **Специализированные делетеры** - для особых случаев
- **Дополнительная функциональность** - специфичные методы
- **Интеграция с API** - совместимость с существующим кодом

### Изучение паттернов
- **RAII** - Resource Acquisition Is Initialization
- **Move semantics** - современная семантика перемещения
- **Template programming** - работа с шаблонами

## Связь с другими примерами

- **15_UniquePointers** - стандартный std::unique_ptr
- **14_VariadicTemplate** - variadic templates C++11
- **13_DeductionGuide** - deduction guides C++17
- **13_CRTP** - паттерн CRTP

## Дополнительные возможности

### Расширенная функциональность
```cpp
template<class T>
struct advanced_smart_ptr {
    // Операторы доступа
    T& operator*() { return *m_ptr; }
    T* operator->() { return m_ptr; }
    
    // Проверка валидности
    explicit operator bool() const { return m_ptr != nullptr; }
    
    // Освобождение ресурса
    void reset(T* new_ptr = nullptr) {
        delete m_ptr;
        m_ptr = new_ptr;
    }
};
```

### Кастомные делетеры
```cpp
template<class T, class Deleter = std::default_delete<T>>
struct custom_smart_ptr {
    Deleter deleter;
    
    ~custom_smart_ptr() {
        deleter(m_ptr);
    }
};
```

### Массивы
```cpp
template<class T>
struct array_smart_ptr {
    T* m_ptr;
    size_t m_size;
    
    ~array_smart_ptr() {
        delete[] m_ptr;
    }
};
```

## Сравнение с std::unique_ptr

### Пользовательский smart_ptr
```cpp
smart_ptr<SomeClass> ptr{new SomeClass()};
// Базовая функциональность
// Простая реализация
// Образовательные цели
```

### std::unique_ptr
```cpp
std::unique_ptr<SomeClass> ptr = std::make_unique<SomeClass>();
// Полная функциональность
// Оптимизированная реализация
// Производственное использование
```

## Ограничения и особенности

### Ограничения пользовательской реализации
- **Базовая функциональность** - не все возможности std::unique_ptr
- **Производительность** - может быть менее оптимизирована
- **Совместимость** - может не работать с некоторыми API

### Особенности реализации
- **Образовательные цели** - понимание принципов работы
- **Простота** - легко понять и модифицировать
- **Расширяемость** - можно добавить дополнительную функциональность

## Рекомендации по изучению

### Этапы изучения
1. **Понимание принципов** - RAII, move semantics
2. **Реализация базовой версии** - конструкторы, деструктор
3. **Добавление move semantics** - оператор перемещения
4. **Запрет копирования** - удаление копирующих операторов
5. **Тестирование** - проверка корректности работы

### Практические упражнения
- **Добавление операторов** - `operator*`, `operator->`
- **Реализация reset()** - явное освобождение памяти
- **Добавление проверок** - валидация указателей
- **Создание make_smart_ptr()** - аналог std::make_unique
