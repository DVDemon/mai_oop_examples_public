#include <iostream>
#include <cassert>

// ============================================================================
// ДЕМОНСТРАЦИЯ СОЗДАНИЯ ПОЛЬЗОВАТЕЛЬСКОГО УМНОГО УКАЗАТЕЛЯ
// ============================================================================

// ============================================================================
// ПРОСТАЯ РЕАЛИЗАЦИЯ УМНОГО УКАЗАТЕЛЯ (АНАЛОГ STD::UNIQUE_PTR)
// ============================================================================

// Пользовательский умный указатель с базовой функциональностью
template<class T>
struct smart_ptr {
    // ========================================================================
    // КОНСТРУКТОРЫ
    // ========================================================================
    
    // Конструктор по умолчанию - создает пустой указатель
    smart_ptr() 
        : m_ptr{nullptr} {
    }
    
    // Конструктор с сырым указателем - принимает владение
    smart_ptr(T* raw_pointer) : m_ptr{raw_pointer} {
    }
    
    // ========================================================================
    // ОПЕРАТОРЫ ПРИСВАИВАНИЯ
    // ========================================================================
    
    // Запрет копирования - копирующий оператор присваивания удален
    smart_ptr& operator=(const smart_ptr&) = delete;
    
    // Оператор перемещения - передача владения
    smart_ptr& operator=(smart_ptr&& other) noexcept {
        if (m_ptr) delete m_ptr;  // Освобождение текущего ресурса
        m_ptr = other.m_ptr;      // Передача владения
        other.m_ptr = nullptr;    // Обнуление источника
        return *this;
    }
    
    // ========================================================================
    // ДЕСТРУКТОР
    // ========================================================================
    
    // Деструктор - автоматическое освобождение памяти
    ~smart_ptr() {
        delete m_ptr;
        m_ptr = nullptr;
    }
    
    // ========================================================================
    // МЕТОДЫ ДОСТУПА
    // ========================================================================
    
    // Получение сырого указателя
    T* get() { 
        return m_ptr; 
    }
    
    // Проверка на валидность
    bool is_valid() const {
        return m_ptr != nullptr;
    }
    
private:
    // ========================================================================
    // ЧЛЕНЫ ДАННЫХ
    // ========================================================================
    
    T* m_ptr;  // Сырой указатель на управляемый объект
};

// ============================================================================
// ТЕСТОВЫЙ КЛАСС ДЛЯ ДЕМОНСТРАЦИИ
// ============================================================================

// Простой класс для демонстрации работы умного указателя
struct SomeClass {
    SomeClass() {
        std::cout << "Constructor called" << std::endl;
    }
    ~SomeClass() {
        std::cout << "Destructor called" << std::endl;
    }
};

// ============================================================================
// ОСНОВНАЯ ФУНКЦИЯ - ДЕМОНСТРАЦИЯ ПОЛЬЗОВАТЕЛЬСКОГО УМНОГО УКАЗАТЕЛЯ
// ============================================================================

auto main() -> int {
    std::cout << "=== ДЕМОНСТРАЦИЯ ПОЛЬЗОВАТЕЛЬСКОГО УМНОГО УКАЗАТЕЛЯ ===" << std::endl << std::endl;
    
    // ========================================================================
    // ДЕМОНСТРАЦИЯ 1: СОЗДАНИЕ И ИСПОЛЬЗОВАНИЕ УМНОГО УКАЗАТЕЛЯ
    // ========================================================================
    std::cout << "1. Создание и использование умного указателя:" << std::endl;
    std::cout << "   start" << std::endl;
    
    {
        // Создание сырого указателя
        SomeClass* raw_pointer = new SomeClass();
        
        // Сравнение размеров
        std::cout << "   size of raw pointer = " << sizeof(raw_pointer) << " bytes" << std::endl;
        
        // Создание умного указателя из сырого
        smart_ptr<SomeClass> smart_pointer_1{raw_pointer};
        std::cout << "   size of smart pointer = " << sizeof(smart_pointer_1) << " bytes" << std::endl;
        
        // Проверка валидности
        if (smart_pointer_1.is_valid()) {
            std::cout << "   Smart pointer is valid" << std::endl;
        }
    }
    std::cout << "   end" << std::endl << std::endl;
    
    // ========================================================================
    // ДЕМОНСТРАЦИЯ 2: ПЕРЕМЕЩЕНИЕ ВЛАДЕНИЯ
    // ========================================================================
    std::cout << "2. Перемещение владения:" << std::endl;
    std::cout << "   start" << std::endl;
    
    {
        // Создание умного указателя
        smart_ptr<SomeClass> source_pointer{new SomeClass()};
        
        // Создание пустого умного указателя
        smart_ptr<SomeClass> destination_pointer;
        
        // Перемещение владения
        destination_pointer = std::move(source_pointer);
        
        // Проверка состояния после перемещения
        if (source_pointer.is_valid()) {
            std::cout << "   Source pointer is still valid (ERROR!)" << std::endl;
        } else {
            std::cout << "   Source pointer is now invalid (correct)" << std::endl;
        }
        
        if (destination_pointer.is_valid()) {
            std::cout << "   Destination pointer is valid (correct)" << std::endl;
        }
    }
    std::cout << "   end" << std::endl << std::endl;
    
    // ========================================================================
    // ДЕМОНСТРАЦИЯ 3: ПРИНЦИПЫ РАБОТЫ УМНОГО УКАЗАТЕЛЯ
    // ========================================================================
    std::cout << "3. Принципы работы умного указателя:" << std::endl;
    std::cout << "   - Единоличное владение ресурсом" << std::endl;
    std::cout << "   - Автоматическое освобождение памяти" << std::endl;
    std::cout << "   - Запрет копирования (copy constructor deleted)" << std::endl;
    std::cout << "   - Разрешение перемещения (move semantics)" << std::endl;
    std::cout << "   - RAII принцип - управление ресурсами" << std::endl << std::endl;
    
    // ========================================================================
    // ДЕМОНСТРАЦИЯ 4: ПРЕИМУЩЕСТВА УМНОГО УКАЗАТЕЛЯ
    // ========================================================================
    std::cout << "4. Преимущества умного указателя:" << std::endl;
    std::cout << "   - Исключение утечек памяти" << std::endl;
    std::cout << "   - Исключение двойного освобождения" << std::endl;
    std::cout << "   - Исключение висячих указателей" << std::endl;
    std::cout << "   - Автоматическое управление жизненным циклом" << std::endl;
    std::cout << "   - Безопасность типов" << std::endl;
    
    return 0;
}