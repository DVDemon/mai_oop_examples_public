# 14_VariadicTemplate - Variadic Templates (Вариативные шаблоны) C++11

## Описание примера

Этот пример демонстрирует **variadic templates (вариативные шаблоны)** в C++11 - мощный механизм для работы с переменным количеством аргументов в шаблонах. Показывает, как создавать функции и классы, которые могут принимать любое количество аргументов разных типов.

## Ключевые концепции

### 1. Пакет параметров (Parameter Pack)
```cpp
template <class First, class... Rest>
void print(const First& first, const Rest&... rest);
```
- **class... Rest** - пакет параметров (parameter pack)
- **Rest...** - распаковка пакета (pack expansion)
- **Переменное количество** аргументов

### 2. Рекурсивная обработка
```cpp
// Базовый случай
template <class T> 
void print(const T& single_element) {
    std::cout << single_element << std::endl;
}

// Рекурсивный случай
template <class First, class... Rest> 
void print(const First& first, const Rest&... rest) {
    std::cout << first << ", ";
    print(rest...); // Рекурсивный вызов
}
```
- **Базовый случай** - остановка рекурсии
- **Рекурсивный случай** - обработка одного элемента + остальных
- **Распаковка пакета** - `rest...`

### 3. Подсчет аргументов
```cpp
template <class... Args>
constexpr size_t count_arguments() {
    return sizeof...(Args);
}
```
- **sizeof...(Args)** - количество аргументов в пакете
- **constexpr** - вычисление на этапе компиляции

## Особенности реализации

### Синтаксис variadic templates
- **class... Args** - объявление пакета параметров
- **Args...** - распаковка пакета
- **sizeof...(Args)** - количество аргументов

### Рекурсивная обработка
- **Базовый случай** - для одного аргумента
- **Рекурсивный случай** - для множества аргументов
- **Распаковка пакета** - передача остальных аргументов

### Типобезопасность
- **Проверка типов** на этапе компиляции
- **Автоматический вывод** типов
- **Ошибки компиляции** при несовместимых типах

## Ожидаемые результаты

```
=== ДЕМОНСТРАЦИЯ VARIADIC TEMPLATES C++11 ===

1. Вариативное сложение:
   add(1.1, 2.0, 21) = 24.1
   Тип результата: d

2. Вариативная печать:
   print(10, 20): 10, 20
   print(100, 200, 300): 100, 200, 300
   print<int, double, int>(1, 2.0, 3): 1, 2, 3
   print("first", 2, "third", 3.14159): first, 2, third, 3.14159

3. Подсчет аргументов:
   count_arguments<int, double, char>() = 3
   count_arguments<int, int, int, int>() = 4

4. Принцип работы variadic templates:
   - class... Rest - пакет параметров (parameter pack)
   - Rest... - распаковка пакета (pack expansion)
   - Рекурсивная обработка - один элемент + остальные
   - Базовый случай - остановка рекурсии
   - sizeof...(Args) - количество аргументов в пакете

5. Преимущества variadic templates:
   - Переменное количество аргументов
   - Типобезопасность на этапе компиляции
   - Эффективность - нет накладных расходов
   - Гибкость - работа с любыми типами
   - Использование в стандартной библиотеке (std::tuple, std::function)
```

## Компиляция и запуск

```bash
# Компиляция (требует C++11 или выше)
g++ -std=c++17 -O2 -o variadic_template_program main.cpp

# Запуск
./variadic_template_program
```

## Образовательная ценность

Этот пример демонстрирует:
- **Variadic templates** - мощный механизм C++11
- **Пакеты параметров** - работа с переменным количеством аргументов
- **Рекурсивную обработку** - базовый и рекурсивный случаи
- **Распаковку пакетов** - передачу аргументов
- **Практическое применение** в реальном коде

## Практическое применение

### Стандартная библиотека C++
- **std::tuple** - кортежи с переменным количеством элементов
- **std::function** - функциональные объекты
- **std::make_shared** - создание shared_ptr
- **std::make_unique** - создание unique_ptr (C++14)

### Библиотеки
- **Boost** - множество variadic templates
- **Собственные библиотеки** - для гибких API
- **Контейнеры** - с переменным количеством аргументов

### Когда использовать variadic templates
- **Переменное количество аргументов** - когда нужно принять любое количество
- **Типобезопасность** - когда важна безопасность типов
- **Эффективность** - когда нужна производительность
- **Гибкость** - когда нужна работа с разными типами

## Связь с другими примерами

- **13_DeductionGuide** - deduction guides C++17
- **13_CRTP** - паттерн CRTP
- **12_ConceptsExample2** - сложные концепции C++20
- **11_ConceptsExample1** - пользовательские концепции

## Дополнительные возможности

### Сложные variadic templates
```cpp
template <class... Args>
auto make_tuple_like(Args... arguments) {
    return std::make_tuple(arguments...);
}

template <class... Args>
void print_with_separator(const std::string& separator, Args... args) {
    ((std::cout << args << separator), ...); // C++17 fold expressions
}
```

### Variadic templates с концепциями (C++20)
```cpp
template <std::integral... Args>
auto sum_integers(Args... args) {
    return (args + ...); // C++17 fold expressions
}
```

### Fold expressions (C++17)
```cpp
template <class... Args>
auto sum_all(Args... args) {
    return (args + ...); // Сумма всех аргументов
}

template <class... Args>
void print_all(Args... args) {
    ((std::cout << args << " "), ...); // Печать всех аргументов
}
```

## Сравнение с альтернативами

### Старый способ (C++03)
```cpp
// Нужно было создавать перегрузки для каждого количества аргументов
void print() {}
void print(int a) { std::cout << a; }
void print(int a, int b) { std::cout << a << ", " << b; }
void print(int a, int b, int c) { std::cout << a << ", " << b << ", " << c; }
// И так далее...
```

### Новый способ (C++11+)
```cpp
template <class... Args>
void print(Args... args) {
    ((std::cout << args << " "), ...); // Один шаблон для любого количества
}
```

## Ограничения и особенности

### Ограничения variadic templates
- **Сложность отладки** - ошибки компиляции могут быть сложными
- **Ограниченная поддержка** - не все компиляторы поддерживают все возможности
- **Производительность компиляции** - может замедлять компиляцию

### Особенности использования
- **Рекурсивная обработка** - всегда нужен базовый случай
- **Распаковка пакетов** - правильный синтаксис распаковки
- **Типобезопасность** - проверка типов на этапе компиляции
