# 12_ConceptsExample2 - Сложные пользовательские концепции C++20

## Описание примера

Этот пример демонстрирует создание **сложных пользовательских концепций** в C++20 с использованием логических операторов и комбинирования встроенных концепций. Показывает, как создавать точные ограничения типов с исключением нежелательных типов.

## Ключевые концепции

### 1. Сложная концепция с логическими операторами
```cpp
template <typename T>
concept Number = (std::integral<T> || std::floating_point<T>) 
                 && !std::same_as<T, bool>
                 && !std::same_as<T, char>;
```
- **std::integral<T> || std::floating_point<T>** - целочисленные ИЛИ с плавающей точкой
- **!std::same_as<T, bool>** - НЕ bool
- **!std::same_as<T, char>** - НЕ char
- **Логические операторы**: || (ИЛИ), && (И), ! (НЕ)

### 2. Использование концепции в шаблонах
```cpp
template <Number T, Number U>
auto add(T first_number, U second_number){
    return first_number + second_number;
}
```
- **Множественные ограничения** на типы параметров
- **Автоматический вывод типа** результата
- **Проверка на этапе компиляции**

### 3. Проверка концепции
```cpp
static_assert(Number<int>);  // Успех
static_assert(Number<bool>); // Ошибка компиляции
```
- **static_assert** для проверки концепций
- **Ошибки компиляции** при несовместимых типах
- **Валидация** на этапе компиляции

## Особенности реализации

### Логические операторы в концепциях
- **|| (ИЛИ)** - объединение условий
- **&& (И)** - пересечение условий
- **! (НЕ)** - отрицание условий
- **Скобки** для группировки выражений

### Комбинирование встроенных концепций
- **std::integral<T>** - целочисленные типы
- **std::floating_point<T>** - типы с плавающей точкой
- **std::same_as<T, U>** - проверка одинаковости типов

### Исключение нежелательных типов
- **bool** - исключен из числовых типов
- **char** - исключен из числовых типов
- **Точное определение** требований к типам

## Ожидаемые результаты

```
=== ДЕМОНСТРАЦИЯ СЛОЖНЫХ ПОЛЬЗОВАТЕЛЬСКИХ КОНЦЕПЦИЙ C++20 ===

1. Проверка концепции на этапе компиляции:
   static_assert(Number<int>) - успешно пройдено
   static_assert(Number<double>) - успешно пройдено
   static_assert(Number<bool>) - ошибка компиляции
   static_assert(Number<char>) - ошибка компиляции

2. Использование функции с концепцией:
   add(20.1, 20) = 40.1
   Тип результата: d

3. Объяснение сложной концепции Number:
   - std::integral<T> || std::floating_point<T> - целочисленные ИЛИ с плавающей точкой
   - !std::same_as<T, bool> - НЕ bool
   - !std::same_as<T, char> - НЕ char
   - Логические операторы: || (ИЛИ), && (И), ! (НЕ)
   - Комбинирование встроенных концепций

4. Примеры типов, которые удовлетворяют концепции Number:
   - int, long, short, unsigned int
   - double, float, long double
   - НЕ bool, char, wchar_t

5. Преимущества сложных концепций:
   - Точное определение требований к типам
   - Исключение нежелательных типов
   - Комбинирование множества условий
   - Более читаемый код по сравнению с SFINAE
   - Лучшие сообщения об ошибках компиляции
```

## Компиляция и запуск

```bash
# Компиляция (требует C++20)
g++ -std=c++20 -O2 -o concepts_example2_program main.cpp

# Запуск
./concepts_example2_program
```

## Образовательная ценность

Этот пример демонстрирует:
- **Создание сложных концепций** с логическими операторами
- **Комбинирование встроенных концепций** для точных ограничений
- **Исключение нежелательных типов** из концепций
- **Проверку концепций** на этапе компиляции
- **Практическое применение** в реальном коде

## Практическое применение

- **Библиотеки** используют сложные концепции для точных ограничений
- **Исключение нежелательных типов** из шаблонов
- **Комбинирование множества условий** в одной концепции
- **Улучшение качества** кода и его понимания

## Связь с другими примерами

- **11_ConceptsExample1** - простые пользовательские концепции
- **10_BuiltInConcepts** - встроенные концепции C++20
- **09_TypeTraits** - стандартные type traits
- **08_Types** - создание собственных type traits

## Дополнительные возможности

### Более сложные концепции
```cpp
template <typename T>
concept NumericAndComparable = Number<T> && 
                              requires(T a, T b) {
                                  a < b;
                                  a > b;
                                  a == b;
                              };
```

### Концепции с параметрами
```cpp
template <typename T, typename U>
concept ConvertibleNumbers = Number<T> && Number<U> && 
                           std::convertible_to<T, U>;
```

### Концепции с выражениями requires
```cpp
template <typename T>
concept ComplexNumber = Number<T> && 
                       requires(T t) {
                           t + t;
                           t - t;
                           t * t;
                           t / t;
                       };
```

## Сравнение с SFINAE

### Старый способ (SFINAE)
```cpp
template<typename T>
typename std::enable_if<
    (std::is_integral<T>::value || std::is_floating_point<T>::value) &&
    !std::is_same<T, bool>::value &&
    !std::is_same<T, char>::value,
    void>::type
function(T value) { /* ... */ }
```

### Новый способ (концепции)
```cpp
template <typename T>
concept Number = (std::integral<T> || std::floating_point<T>) 
                 && !std::same_as<T, bool>
                 && !std::same_as<T, char>;

template <Number T>
void function(T value) { /* ... */ }
```
